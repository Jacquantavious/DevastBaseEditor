<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>149x149 Grid Panner & Zoomer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Set the body and HTML to full height to ensure centering works well */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* Dark background for contrast */
        }
        /* Style the canvas to ensure it doesn't cause overflow and is treated as a block element */
        #gridCanvas {
            max-width: 90vh; /* Limit size to viewport height */
            max-height: 90vh; /* Limit size to viewport height */
            margin: auto;
            display: block;
            border: 2px solid #505050; /* Subtle border around the whole grid */
            cursor: grab; /* Indicate it's movable */
            touch-action: none; /* Prevent unwanted browser touch gestures */
            border-radius: 0.5rem; /* Rounded corners */
        }
        /* Style for the code output textarea */
        #map-code-output {
            resize: none;
            font-family: monospace;
            word-break: break-all; /* Ensure long string wraps correctly */
        }
    </style>
    <script>
        // Constants for the grid
        const GRID_SIZE = 149;
        const GRID_FILL_COLOR = '#38523A'; // Dark olive green
        const GRID_LINE_COLOR = '#000000'; // Black lines
        const BACKGROUND_COLOR = '#1a1a1a'; // Match body background
        const DRAG_THRESHOLD = 5; // Pixels distance before a click becomes a drag/pan

        // Configuration for different object types
        const OBJECT_CONFIGS = {
            'research': {
                name: 'Research (3x1 Blue)',
                color: '#4C60F5', // Bright Blue 
                length: 3, 
                widthRatio: 2/3
            },
            'smelter': { 
                name: 'Smelter (3x1 Red)', 
                color: '#E32636', // Bright Red for the base
                length: 3, 
                widthRatio: 2/3
            },
            'tesla': { 
                name: 'Tesla (3x1 Green)', 
                color: '#00AA00', // Bright Green
                length: 3, 
                widthRatio: 2/3
            },
            'fridge': {
                name: 'Fridge (1x1 Half Gray)',
                color: '#A9A9A9', // Dark Gray
                length: 1, 
                widthRatio: 1 // Full cell, but drawing function will handle half fill
            },
            // Workbench (1x1 Brown Circle)
            'workbench': {
                name: 'Workbench (1x1 Brown Circle)',
                color: '#A0522D', // Sienna Brown
                length: 1, 
                widthRatio: 1 // Full cell, drawing function will handle the circle shape
            },
            // Firepit (1x1 Yellow Circle)
            'firepit': {
                name: 'Firepit (1x1 Yellow Circle)',
                color: '#FFD700', // Gold/Yellow
                length: 1,
                widthRatio: 1 // Full cell, drawing function will handle the circle shape
            }
        };

        // Known IDs that should be output as integers, not strings or UUIDs
        const KNOWN_INTEGER_IDS = {
            'fridge': 61,
            'workbench': 19,
            'firepit': 48,
        };

        // State for Pan and Zoom
        let scale = 1.0;
        let panX = 0;
        let panY = 0;
        let baseSize = 0; // The calculated size of the canvas based on window dimensions
        
        // State for Drag/Click Detection
        let isDragging = false; // Is *any* mouse button currently down?
        let isPanning = false; // Did a middle-click pan or a left-click drag occur?
        let clickStartX = 0;
        let clickStartY = 0;
        let lastPanX = 0; // Stores last position for middle-click panning
        let lastPanY = 0;

        let canvas;
        let ctx;

        // --- State for Placed Objects ---
        /** * Array to store placed objects. All initial features have been removed.
         * Structure: { type: string, row: number, col: number, rotation: number, id: string | number }
         */
        let specialObjects = [
            // The grid starts empty in the top-left corner as requested.
        ];
        let selectedObjectType = 'workbench'; // Set default selection to the new item

        // --- State for Ghost Preview ---
        let ghostRow = -1; // Current row for ghost preview
        let ghostCol = -1; // Current column for ghost preview
        let ghostRotation = 0; // Rotation for the ghost preview (0, 90, 180, 270)


        /**
         * Recalculates the base size of the canvas based on window dimensions.
         */
        function updateBaseSize() {
            const padding = 80; // Padding for the canvas within the viewport
            // Ensure the base size is a perfect square constrained by the viewport
            let size = Math.min(window.innerWidth, window.innerHeight) - padding;
            // Add a minimum size to prevent issues on tiny screens
            baseSize = Math.max(size, 300);
            
            canvas.width = baseSize;
            canvas.height = baseSize;
        }

        /**
         * Calculates the grid cell (row, col) from screen coordinates (x, y) after pan and zoom.
         * @param {number} screenX X-coordinate relative to the canvas.
         * @param {number} screenY Y-coordinate relative to the canvas.
         * @returns {{row: number, col: number} | null} The cell coordinates or null if outside the grid.
         */
        function getCellFromScreenCoords(screenX, screenY) {
            const originalCellSize = baseSize / GRID_SIZE;

            // Inverse transformation: 
            const unPannedX = screenX - panX;
            const unPannedY = screenY - panY;
            
            const worldX = unPannedX / scale;
            const worldY = unPannedY / scale;

            // Check if within the 0 to baseSize boundaries of the grid content
            if (worldX < 0 || worldX >= baseSize || worldY < 0 || worldY >= baseSize) {
                return null;
            }

            // Convert world coordinates to cell index (0 to GRID_SIZE - 1)
            const col = Math.floor(worldX / originalCellSize);
            const row = Math.floor(worldY / originalCellSize);
            
            // Clamp coordinates to grid limits
            const clampedRow = Math.min(GRID_SIZE - 1, Math.max(0, row));
            const clampedCol = Math.min(GRID_SIZE - 1, Math.max(0, col));

            return { row: clampedRow, col: clampedCol };
        }

        /**
         * Draws the red square detail for the middle block of the research feature, in the bottom half.
         * Assumes the context is already translated to the center of the middle block.
         * @param {number} cellSize The original cell size (width/height).
         * @param {number} widthRatio The height ratio of the blue feature (2/3).
         */
        function drawResearchInternalDetail(cellSize, widthRatio) {
            // Context (0, 0) is the center of the middle cell.

            // --- 1. Red Rectangle (Small, in the bottom half of the blue feature) ---
            const redSize = cellSize * 0.4; // 40% of the cell width/height for the square
            const drawHeight = cellSize * widthRatio; // The actual height of the blue feature part

            // Center X in the cell
            const redX = -redSize / 2;
            
            // Calculate Y position: center it within the bottom half of the blue feature [0, drawHeight/2]
            const featureBottomHalfHeight = drawHeight / 2;
            const redCenterY = featureBottomHalfHeight / 2; 
            const redY = redCenterY - redSize / 2;

            ctx.fillStyle = '#E32636'; // Bright Red (same as smelter base color for consistency)
            ctx.fillRect(redX, redY, redSize, redSize);
        }

        /**
         * Draws a blue square at the bottom of the smelter's or Tesla's middle block to indicate rotation point.
         * Assumes the context is already translated to the center of the middle block (0, 0).
         * @param {number} cellSize The original cell size (width/height).
         * @param {number} widthRatio The height ratio of the feature (2/3).
         */
        function drawSmelterCenterSquare(cellSize, widthRatio) {
            const squareSize = cellSize * 0.4; // 40% of the cell width/height
            const drawHeight = cellSize * widthRatio;
            
            // --- Vertical positioning ---
            // 1. Get the height of the bottom half of the feature (from cell center (0) to feature bottom (drawHeight/2))
            const featureBottomHalfHeight = drawHeight / 2;
            
            // 2. Center the square vertically within that bottom half [0, featureBottomHalfHeight]
            // This offsets it from the center towards the bottom edge of the feature.
            const blueCenterY = featureBottomHalfHeight / 2; 
            
            // 3. Calculate the top edge draw position (Y coordinate)
            const blueY = blueCenterY - squareSize / 2;

            // --- Drawing ---
            ctx.fillStyle = '#1e90ff'; // Dodger Blue (Used for Smelter and Tesla detail)
            // Center X in the cell, use calculated Y
            const blueX = -squareSize / 2;
            ctx.fillRect(blueX, blueY, squareSize, squareSize);
        }

        /**
         * Draws a single feature (placed or ghost) onto the canvas.
         * @param {object} obj The feature object {type, row, col, rotation}.
         * @param {number} originalCellSize The base size of a single cell.
         * @param {number} scale The current zoom scale.
         * @param {boolean} isGhost If true, applies transparency.
         */
        function drawFeature(obj, originalCellSize, scale, isGhost = false) {
            const config = OBJECT_CONFIGS[obj.type];
            if (!config) return;
            if (obj.row < 0 || obj.col < 0) return; // Don't draw if ghost is off-screen

            // Apply transparency for ghost
            if (isGhost) {
                ctx.globalAlpha = 0.33; // 33% transparency
            }

            // 1. Calculate World Center of the middle cell (the placement anchor)
            const cellCenterX = obj.col * originalCellSize + originalCellSize / 2;
            const cellCenterY = obj.row * originalCellSize + originalCellSize / 2;
            
            // Save context for object-specific rotation/translation
            ctx.save();
            
            // Move origin to the object's center for rotation
            ctx.translate(cellCenterX, cellCenterY);
            // Rotate (convert degrees to radians)
            ctx.rotate(obj.rotation * Math.PI / 180);

            // Calculate half the cell size for easier centered drawing
            const S = originalCellSize;
            const halfS = S / 2;

            // --- Logic for 3x1 features (Research, Smelter, Tesla) ---
            if (config.length > 1) {
                const featureTotalLength = originalCellSize * config.length; 
                const drawLength = featureTotalLength; 
                const drawHeight = originalCellSize * config.widthRatio;
                
                const featureDrawX = -drawLength / 2;
                const featureDrawY = -drawHeight / 2;

                // Draw the primary feature rectangle
                ctx.fillStyle = config.color;
                ctx.fillRect(featureDrawX, featureDrawY, drawLength, drawHeight);

                // Add a border
                ctx.strokeStyle = isGhost ? '#AAAAAA' : '#FFFFFF';
                ctx.lineWidth = 2 / scale;
                ctx.strokeRect(featureDrawX, featureDrawY, drawLength, drawHeight);

                // Draw Details based on object type, if not too zoomed out
                if (scale > 0.5) {
                    if (obj.type === 'research') {
                        drawResearchInternalDetail(originalCellSize, config.widthRatio);
                    } else if (obj.type === 'smelter' || obj.type === 'tesla') { 
                        drawSmelterCenterSquare(originalCellSize, config.widthRatio); 
                    }
                }
            } 
            // --- Logic for 1x1 Half-Square Fridge (Rotational) ---
            else if (obj.type === 'fridge') {
                // Draw the gray half (always top half relative to the current rotation).
                ctx.fillStyle = config.color;
                ctx.fillRect(-halfS, -halfS, S, halfS); 

                // Draw the border around the full 1x1 cell
                ctx.strokeStyle = isGhost ? '#AAAAAA' : '#FFFFFF';
                ctx.lineWidth = 2 / scale;
                ctx.strokeRect(-halfS, -halfS, S, S);
            }
            // --- Logic for 1x1 Circle Workbench or Firepit ---
            else if (obj.type === 'workbench' || obj.type === 'firepit') {
                const radius = halfS * 0.9; // Radius is 90% of half the cell size (to leave a small gap/margin)
                
                // Draw the circle
                ctx.fillStyle = config.color;
                ctx.beginPath();
                // Center (0, 0), Radius, Start Angle (0), End Angle (2 * PI)
                ctx.arc(0, 0, radius, 0, 2 * Math.PI); 
                ctx.fill();

                // Add a border
                ctx.strokeStyle = isGhost ? '#AAAAAA' : '#FFFFFF';
                ctx.lineWidth = 2 / scale;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                ctx.stroke();

            }

            // Restore context to undo rotation/translation
            ctx.restore();
            
            // Reset global transparency if it was set
            if (isGhost) {
                ctx.globalAlpha = 1.0;
            }
        }


        /**
         * Draws the 149x149 grid onto the canvas using current pan and zoom settings.
         */
        function drawGrid() {
            if (!ctx) return;

            // 1. Clear the canvas and fill the background
            ctx.fillStyle = BACKGROUND_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Save the context state before applying pan/zoom
            ctx.save();
            
            // Apply global pan and zoom transformations
            ctx.translate(panX, panY);
            ctx.scale(scale, scale);

            // Calculate the size of a single cell at scale 1.0 (the base cell size)
            const originalCellSize = baseSize / GRID_SIZE;

            // 3. Draw the filled grid area (this drawing will be transformed)
            ctx.fillStyle = GRID_FILL_COLOR;
            ctx.fillRect(0, 0, baseSize, baseSize);

            // 4. Draw the grid lines (transformed)
            ctx.strokeStyle = GRID_LINE_COLOR;
            ctx.lineWidth = 1 / scale; 
            
            for (let i = 0; i <= GRID_SIZE; i++) {
                const position = i * originalCellSize;
                ctx.beginPath();
                ctx.moveTo(position, 0);
                ctx.lineTo(position, baseSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, position);
                ctx.lineTo(baseSize, position);
                ctx.stroke();
            }
            
            // --- 5. Draw Ghost Preview ---
            if (!isDragging && ghostRow >= 0 && ghostCol >= 0) {
                 const ghostObject = {
                    type: selectedObjectType,
                    row: ghostRow,
                    col: ghostCol,
                    rotation: ghostRotation
                 };
                 drawFeature(ghostObject, originalCellSize, scale, true);
            }

            // --- 6. Draw Placed Special Objects ---
            specialObjects.forEach(obj => {
                drawFeature(obj, originalCellSize, scale, false);
            });

            // 7. Restore the global context state
            ctx.restore();
        }

        /**
         * Handles the mouse wheel event for zooming in and out.
         */
        function handleWheel(event) {
            event.preventDefault();

            const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1; 
            const newScale = Math.max(0.1, Math.min(scale * zoomFactor, 10.0)); // Clamp scale

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const worldX = (mouseX - panX) / scale;
            const worldY = (mouseY - panY) / scale;

            panX = mouseX - worldX * newScale;
            panY = mouseY - worldY * newScale;

            scale = newScale;
            drawGrid();
        }

        /**
         * Handles the start of a pan (middle mouse button down) or drag check (left mouse button down).
         */
        function handleMouseDown(event) {
            isDragging = true; // Track that A button is down
            isPanning = false; // Initial click, not a pan yet
            clickStartX = event.clientX;
            clickStartY = event.clientY;
            
            if (event.button === 1) { // Middle Click (for panning)
                event.preventDefault(); // Prevent default scroll behavior
                canvas.style.cursor = 'grabbing';
                lastPanX = event.clientX;
                lastPanY = event.clientY;
            } 

            // Hide ghost when a button is pressed
            ghostRow = -1;
            ghostCol = -1;
            drawGrid(); 
        }

        /**
         * Handles the end of a pan (mouse up or leave).
         */
        function handleMouseUp() {
            isDragging = false;
            canvas.style.cursor = 'grab'; // Reset cursor
        }

        /**
         * Handles mouse movement for panning (middle button) and drag detection (left button) or ghost preview.
         */
        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            if (isDragging) {
                // Check if the middle button (bit 4) is currently held down
                const isMiddleButtonDown = event.buttons & 4; 
                
                if (isMiddleButtonDown) {
                    // Panning logic (only for middle button)
                    const dx = event.clientX - lastPanX;
                    const dy = event.clientY - lastPanY;

                    panX += dx;
                    panY += dy;

                    lastPanX = event.clientX;
                    lastPanY = event.clientY;

                    isPanning = true; 
                    
                } else if (event.buttons & 1) {
                    // Left button (bit 1) held down - check for drag to prevent click placement (no panning)
                    const totalDistMoved = Math.hypot(event.clientX - clickStartX, event.clientY - clickStartY);
                    if (totalDistMoved > DRAG_THRESHOLD) {
                        isPanning = true; // Prevents placement on mouseup/click
                    }
                }
                
                drawGrid();
                
            } else {
                // Not dragging, update ghost position
                const cell = getCellFromScreenCoords(mouseX, mouseY);
                if (cell && (cell.row !== ghostRow || cell.col !== ghostCol)) {
                    ghostRow = cell.row;
                    ghostCol = cell.col;
                    drawGrid();
                } else if (!cell && (ghostRow !== -1)) {
                    ghostRow = -1;
                    ghostCol = -1;
                    drawGrid();
                }
            }
        }

        /**
         * Handles key presses (WASD, R) for panning and ghost rotation.
         */
        function handleKeyDown(event) {
            const panSpeed = 30; // Base speed for panning
            let moved = false;
            
            // Movement amount is scaled inversely with zoom level for consistent movement speed
            const distance = panSpeed / scale; 

            switch (event.key.toLowerCase()) {
                case 'w': // Up
                    panY += distance;
                    moved = true;
                    break;
                case 's': // Down
                    panY -= distance;
                    moved = true;
                    break;
                case 'a': // Left
                    panX += distance;
                    moved = true;
                    break;
                case 'd': // Right
                    panX -= distance;
                    moved = true;
                    break;
                
                case 'r': // Rotate only the ghost preview
                    event.preventDefault(); // Prevent default browser actions
                    // Rotate by 90 degrees, wrap at 360
                    ghostRotation = (ghostRotation + 90) % 360; 
                    moved = true; // Force redraw to show new rotation
                    break;
            }

            if (moved) {
                drawGrid();
            }
        }

        /**
         * Handles click event for placing objects.
         */
        function handleCanvasClick(event) {
            // Check if the event was a middle click (which would be for panning)
            if (event.button !== 0) {
                return;
            }

            // If significant panning/dragging occurred during this cycle, prevent placement.
            if (isPanning) {
                isPanning = false; // Reset the flag for the next interaction
                return;
            }

            const cell = getCellFromScreenCoords(event.clientX - canvas.getBoundingClientRect().left, 
                                                event.clientY - canvas.getBoundingClientRect().top);

            if (cell) {
                const config = OBJECT_CONFIGS[selectedObjectType];
                if (!config) return;

                // Check if the clicked cell (which is the center) is already occupied
                const isOccupied = specialObjects.some(obj => 
                    obj.row === cell.row && obj.col === cell.col
                );

                if (!isOccupied) {
                    // Place the new object using the current ghost rotation
                    
                    let newId;
                    // Use known integer IDs if applicable, otherwise use a generic UUID string (for 3x1 items)
                    if (KNOWN_INTEGER_IDS[selectedObjectType] !== undefined) {
                        newId = KNOWN_INTEGER_IDS[selectedObjectType];
                    } else {
                        // For 3x1 items, we use a random string ID
                        newId = crypto.randomUUID(); 
                    }

                    specialObjects.push({
                        type: selectedObjectType,
                        row: cell.row,
                        col: cell.col,
                        id: newId,
                        rotation: ghostRotation // Use the rotation from the ghost preview
                    });
                    
                    document.getElementById('placement-status').textContent = 
                        `${config.name} placed at (${cell.row}, ${cell.col}) @ ${ghostRotation}°`;
                } else {
                    // Remove existing object if clicked again (simple toggle)
                    const initialCount = specialObjects.length;
                    specialObjects = specialObjects.filter(obj => 
                        !(obj.row === cell.row && obj.col === cell.col)
                    );

                    if (specialObjects.length < initialCount) {
                         document.getElementById('placement-status').textContent = 
                        `Removed item at (${cell.row}, ${cell.col})`;
                    } else {
                        document.getElementById('placement-status').textContent = 
                        `Cell (${cell.row}, ${cell.col}) already occupied by a feature center.`;
                    }
                }

                drawGrid();
            }
        }

        /**
         * Generates the map code array in the custom string format: !b={id}::{x}:{y}:{r}!b={id2}::...
         */
        function generateMapCode() {
            // Map the objects to the custom string format
            const codeString = specialObjects.map(obj => {
                const id = obj.id;
                const x = obj.col; // x coordinate is the column
                const y = obj.row; // y coordinate is the row
                const r = obj.rotation;

                // Format: !b={id}::{x}:{y}:{r} 
                // Using '::' for the empty second ID as requested.
                return `!b=${id}::${x}:${y}:${r}`;
            }).join(''); // Join all item strings together without separators

            
            document.getElementById('map-code-output').value = codeString;
            document.getElementById('code-output-container').classList.remove('hidden');
            
            // Update status and scroll to the code output
            document.getElementById('placement-status').textContent = 
                `Map code generated in custom string format for ${specialObjects.length} items. Scroll down to copy.`;
            
            document.getElementById('code-output-container').scrollIntoView({ behavior: 'smooth' });
        }

        /**
         * Copies the generated custom code string to the clipboard.
         */
        function copyCode() {
            const output = document.getElementById('map-code-output');
            output.select();
            output.setSelectionRange(0, 99999); // For mobile devices
            
            // Execute the copy command
            try {
                document.execCommand('copy');
                document.getElementById('placement-status').textContent = 
                    'Map code successfully copied to clipboard!';
            } catch (err) {
                document.getElementById('placement-status').textContent = 
                    'Failed to copy code. Please copy manually from the box.';
            }
        }


        /**
         * Handles change on the item selection dropdown.
         */
        function handleItemChange(event) {
            selectedObjectType = event.target.value;
            // Reset ghost rotation when changing object type
            ghostRotation = 0; 
            document.getElementById('placement-status').textContent = 
                `Ready to place: ${OBJECT_CONFIGS[selectedObjectType].name}`;
        }

        /**
         * Initialization function
         */
        function init() {
            canvas = document.getElementById('gridCanvas');
            ctx = canvas.getContext('2d');

            // Set initial base size and draw
            updateBaseSize();
            drawGrid();

            // Setup Event Listeners
            window.addEventListener('resize', () => {
                updateBaseSize();
                drawGrid();
            });
            canvas.addEventListener('wheel', handleWheel);
            
            // Mouse interaction listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', () => {
                handleMouseUp();
                // Hide ghost when cursor leaves canvas
                ghostRow = -1;
                ghostCol = -1;
                drawGrid();
            });
            canvas.addEventListener('mousemove', handleMouseMove);
            
            // Placement listener (use click after mouseup/mousemove handlers)
            canvas.addEventListener('click', handleCanvasClick);

            // Listen on the document so keys work even if the canvas is not explicitly focused
            document.addEventListener('keydown', handleKeyDown); 
            
            // Code generation buttons
            document.getElementById('generate-code-btn').addEventListener('click', generateMapCode);
            document.getElementById('copy-code-btn').addEventListener('click', copyCode);


            // Initialize the dropdown options
            const select = document.getElementById('item-select');
            // Clear existing options just in case (though only one init runs)
            select.innerHTML = ''; 
            for (const key in OBJECT_CONFIGS) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = OBJECT_CONFIGS[key].name;
                select.appendChild(option);
            }
            select.value = selectedObjectType; // Set the default selected value
            select.addEventListener('change', handleItemChange);

            // Set initial status message
            document.getElementById('placement-status').textContent = 
                `Ready to place: ${OBJECT_CONFIGS[selectedObjectType].name}`;
        }

        // Run the initialization once the DOM is fully loaded
        window.onload = init;
    </script>
</head>
<body class="flex flex-col items-center justify-start p-4 h-screen">

    <!-- Header and Information -->
    <div class="text-white text-center mb-4 mt-4 relative w-full max-w-7xl">
        <h1 class="text-3xl font-bold mb-2">149x149 Grid Map Editor</h1>
        <p class="text-sm text-gray-400">
            Use the **Scroll Wheel** to zoom, **WASD** keys or **Middle Mouse Click & Drag** to pan. Press **R** to rotate the **ghost preview**.
        </p>
        
        <!-- Dropdown Menu for Placement and GENERATE BUTTON (Top Right) -->
        <div class="absolute top-0 right-0 p-3 bg-gray-700/50 rounded-lg shadow-xl backdrop-blur-sm flex flex-col items-stretch space-y-2">
            <label for="item-select" class="text-xs text-gray-200 block mb-1">Place Feature:</label>
            <select id="item-select" class="p-2 text-sm bg-gray-800 text-white border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 transition duration-150">
                <!-- Options populated by JS -->
            </select>
            <p id="placement-status" class="text-xs text-blue-300 mt-2 h-4"></p>

            <!-- CODE GENERATION BUTTON (New Location) -->
            <button id="generate-code-btn" class="px-3 py-2 bg-teal-600 hover:bg-teal-700 text-white font-semibold text-sm rounded-md shadow-lg transition duration-200 transform hover:scale-[1.02]">
                Generate Map Code
            </button>

        </div>
    </div>

    <!-- Canvas Container -->
    <div class="flex flex-grow items-center justify-center w-full max-w-full rounded-xl mb-4">
        <canvas id="gridCanvas"></canvas>
    </div>


    <!-- Code Output Section (Initially hidden) -->
    <div id="code-output-container" class="hidden w-full max-w-4xl p-4 bg-gray-800 rounded-lg shadow-2xl mb-8">
        <h2 class="text-xl font-bold text-gray-100 mb-3">Devast.io Map Code Output (Custom String)</h2>
        <textarea id="map-code-output" rows="10" class="w-full p-3 bg-gray-900 text-green-300 border border-gray-700 rounded-md"></textarea>
        <!-- This is the Copy Code button, which calls the copyCode function -->
        <button id="copy-code-btn" class="mt-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-medium rounded-md transition duration-150">
            Copy Code to Clipboard
        </button>
    </div>

</body>
</html>
