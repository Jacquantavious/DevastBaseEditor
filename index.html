<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Devast Base Editor (H for Help)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for Game/App Styling */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* Dark background for contrast */
            overflow: hidden; /* Prevent body scroll */
        }
        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            width: 100%;
            height: 100%;
            overflow-y: auto; /* Allow scrolling if content is taller than screen */
        }
        /* Style the canvas to ensure it doesn't cause overflow and is treated as a block element */
        #gridCanvas {
            max-width: 90vh; /* Limit size to viewport height */
            max-height: 90vh; /* Limit size to viewport height */
            margin: auto;
            display: block;
            border: 2px solid #505050;
            cursor: none; /* Hide default cursor when over the canvas */
            image-rendering: pixelated; /* Ensures clean image scaling */
        }
        /* Styles for the Tooltip/Ghost Cursor */
        #ghost-cursor {
            position: absolute;
            pointer-events: none; /* Ignore mouse events */
            width: 32px; /* Default size, will be updated by JS */
            height: 32px; /* Default size, will be updated by JS */
            background-color: rgba(255, 255, 255, 0.3); /* Semi-transparent white overlay */
            border: 2px solid #ffffff;
            box-sizing: border-box;
            z-index: 100;
            opacity: 0; /* Hidden by default */
            display: none; /* Hidden by default, changed to 'block' on hover */
        }
        #ghost-cursor.invalid {
            background-color: rgba(255, 0, 0, 0.4);
            border: 2px solid #ff0000;
        }
        /* Style for the Selection Box */
        #selection-box {
            position: absolute;
            pointer-events: none;
            border: 2px dashed #4ade80; /* Green dashed border */
            background-color: rgba(74, 222, 128, 0.1); /* Light green fill */
            box-sizing: border-box;
            z-index: 90;
            display: none; /* Hidden by default */
        }

        /* Modal specific styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #2a2a2a;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
    </style>
</head>
<body onload="init()">
    <div class="app-container">
        <header class="w-full max-w-5xl mb-4 p-4 flex justify-between items-center bg-gray-800 rounded-lg shadow-lg">
            <h1 class="text-2xl font-bold text-white">Devast Base Editor</h1>
            <div class="space-x-4">
                <button onclick="toggleHelpModal()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition duration-150">
                    Help (H)
                </button>
                <button onclick="exportMapData()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition duration-150">
                    Export JSON
                </button>
            </div>
        </header>

        <div class="flex flex-col lg:flex-row w-full max-w-5xl gap-4">
            <div class="flex-grow flex flex-col items-center p-4 bg-gray-800 rounded-lg shadow-lg relative">
                <canvas id="gridCanvas"></canvas>
                <div id="ghost-cursor"></div>
                <div id="selection-box"></div>
                <div id="coords-display" class="mt-2 text-white font-mono text-sm">
                    X: 0, Y: 0 (Grid: 0, 0)
                </div>
                <div id="block-count" class="text-gray-400 text-xs">
                    Total Blocks Placed: 0
                </div>
            </div>

            <div class="w-full lg:w-64 p-4 bg-gray-800 rounded-lg shadow-lg space-y-4">
                <div>
                    <h2 class="text-xl font-semibold text-white mb-2">Placement Mode</h2>
                    <div class="flex space-x-2">
                        <button id="mode-click" onclick="setMode(MODES.CLICK)" class="mode-button bg-blue-600 text-white p-2 rounded flex-1">Click (üñ±Ô∏è)</button>
                        <button id="mode-line" onclick="setMode(MODES.LINE)" class="mode-button bg-gray-600 text-white p-2 rounded flex-1">Line (üìè)</button>
                        <button id="mode-clone" onclick="setMode(MODES.CLONE)" class="mode-button bg-gray-600 text-white p-2 rounded flex-1">Clone (üìã)</button>
                        <button id="mode-delete" onclick="setMode(MODES.DELETE)" class="mode-button bg-red-600 text-white p-2 rounded flex-1">Delete (üóëÔ∏è)</button>
                    </div>
                </div>

                <div>
                    <h2 class="text-xl font-semibold text-white mb-2">Select Block</h2>
                    <select id="block-selector" onchange="updateSelectedBlock()" class="w-full p-2 rounded bg-gray-700 text-white border border-gray-600">
                        </select>
                </div>
                
                <div>
                    <h2 class="text-xl font-semibold text-white mb-2">Ghost Controls</h2>
                    <div class="flex space-x-2">
                        <button onclick="rotateGhost(1)" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded transition duration-150 flex-1">
                            Rotate (R)
                        </button>
                        <button onclick="flipGhost()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition duration-150 flex-1">
                            Flip (F)
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <footer class="w-full max-w-5xl mt-4 p-4 flex justify-between items-center bg-gray-800 rounded-lg shadow-lg">
            <input type="file" id="importFile" accept=".json" class="text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100" />
            <button onclick="clearMap()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-150">
                Clear Map
            </button>
        </footer>
    </div>
    
    <div id="helpModal" class="modal-overlay hidden" onclick="if(event.target.id === 'helpModal') toggleHelpModal()">
        <div class="modal-content text-white">
            <h2 class="text-3xl font-bold text-indigo-400 mb-4 border-b border-gray-700 pb-2">Editor Controls & Help</h2>
            
            <div class="space-y-4">
                <p class="text-lg text-gray-300">Welcome to the Devast Base Editor. Use the tools below to design your base.</p>
                
                <h3 class="text-xl font-semibold text-indigo-300">Navigation</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
                    <li>**Zoom**: Use the **Scroll Wheel** (or pinch on touch devices).</li>
                    <li>**Pan/Move**: Use **WASD** keys or **Middle Mouse Click & Drag**.</li>
                    <li>**Rotate Ghost Preview**: Press **R** to rotate the object ghost before placing (only for applicable items like 3x1 features, **Fridge**, **Door**, or **Bag**).</li>
                    <li>**Toggle Help**: Press **H** to show/hide this modal.</li>
                </ul>

                <h3 class="text-xl font-semibold text-indigo-300">Placement Modes</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
                    <li>**Click (üñ±Ô∏è)**: Single click to place or remove the selected object.</li>
                    <li>**Line (üìè)**: Click and drag to quickly place objects in a straight line (horizontal or vertical).</li>
                    <li>**Clone (üìã)**: First drag a box to select an area, then click to place the copy of that area.</li>
                    <li>**Delete (üóëÔ∏è)**: Click and drag a box to delete all objects within that area.</li>
                </ul>
            </div>
            
            <div class="mt-6 text-center text-sm text-gray-500 border-t border-gray-700 pt-3">
                <p>The base grid is **149x149**. Start building by closing this window!</p>
            </div>
        </div>
    </div>
    
    <script>
        // --- Configuration ---
        const GRID_SIZE = 149; // Devast Base size
        const CELL_PIXELS = 32; // Size of a single grid cell in screen pixels (before zoom)
        
        // Block definitions (type: [key, sizeX, sizeY, imagePath]) - imagePath is null to force color rendering
        const BLOCKS = {
            FLOOR: ['FLOOR', 1, 1, null],
            WALL: ['WALL', 1, 1, null],
            DOOR: ['DOOR', 1, 2, null], 
            BENCH: ['BENCH', 3, 1, null], 
            RESEARCH: ['RESEARCH', 3, 1, null], 
            // Add more blocks here
        };
        
        // --- Global State ---
        let scale = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        let selectedBlockKey = 'FLOOR';
        let ghostBlock = {
            key: selectedBlockKey,
            x: -1, y: -1, 
            width: BLOCKS[selectedBlockKey][1], 
            height: BLOCKS[selectedBlockKey][2],
            rotation: 0, // 0 (North), 90 (East), 180 (South), 270 (West)
            flipped: false // Horizontal flip
        };
        
        // Map data structure: grid[x][y] = { blockKey, rotation, flipped }
        let mapData = Array.from({ length: GRID_SIZE }, () => 
            Array.from({ length: GRID_SIZE }, () => null)
        );
        
        // Placement Modes
        const MODES = {
            CLICK: 'CLICK',
            LINE: 'LINE',
            CLONE: 'CLONE',
            DELETE: 'DELETE'
        };
        let currentMode = MODES.CLICK;
        let isDrawing = false; // For Line/Delete mode
        let startGridX = -1;
        let startGridY = -1;
        let cloneData = null; // Stores copied block data for CLONE mode

        // --- DOM Elements ---
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const ghostCursor = document.getElementById('ghost-cursor');
        const selectionBox = document.getElementById('selection-box');
        const coordsDisplay = document.getElementById('coords-display');
        const blockCountDisplay = document.getElementById('block-count');

        // --- Utility Functions ---

        /**
         * Converts canvas pixel coordinates to grid coordinates.
         * @param {number} clientX - Mouse X position relative to the viewport.
         * @param {number} clientY - Mouse Y position relative to the viewport.
         * @returns {{gridX: number, gridY: number}} The grid coordinates.
         */
        function clientToGrid(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            
            // Mouse position relative to the canvas
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;
            
            // Pixel coordinates in the virtual grid space
            const virtualX = (canvasX / scale) - panX;
            const virtualY = (canvasY / scale) - panY;
            
            // Grid coordinates
            let gridX = Math.floor(virtualX / CELL_PIXELS);
            let gridY = Math.floor(virtualY / CELL_PIXELS);

            // Clamp to grid boundaries
            gridX = Math.max(0, Math.min(GRID_SIZE - 1, gridX));
            gridY = Math.max(0, Math.min(GRID_SIZE - 1, gridY));

            return { gridX, gridY };
        }

        /**
         * Converts grid coordinates to a screen position.
         * @param {number} gridX - Grid X coordinate.
         * @param {number} gridY - Grid Y coordinate.
         * @returns {{screenX: number, screenY: number}} The screen pixel coordinates relative to the canvas.
         */
        function gridToCanvas(gridX, gridY) {
            const canvasRect = canvas.getBoundingClientRect();
            const virtualX = (gridX * CELL_PIXELS) + panX;
            const virtualY = (gridY * CELL_PIXELS) + panY;
            
            const screenX = (virtualX * scale) + canvasRect.left;
            const screenY = (virtualY * scale) + canvasRect.top;

            return { screenX, screenY };
        }

        /**
         * Checks if a block of a given size can be placed at (gridX, gridY) without overlapping a different block.
         * @param {number} gridX - Top-left X coordinate.
         * @param {number} gridY - Top-left Y coordinate.
         * @param {number} width - Block width.
         * @param {number} height - Block height.
         * @param {string} key - Block key being placed (to allow placing same block on top)
         * @param {boolean} [ignoreKey=false] - If true, treats any existing block as an overlap.
         * @returns {boolean} True if the area is valid for placement.
         */
        function isValidPlacement(gridX, gridY, width, height, key, ignoreKey = false) {
            // Check bounds
            if (gridX < 0 || gridY < 0 || gridX + width > GRID_SIZE || gridY + height > GRID_SIZE) {
                return false;
            }

            // Check for overlaps with other blocks
            for (let x = gridX; x < gridX + width; x++) {
                for (let y = gridY; y < gridY + height; y++) {
                    const existingBlock = mapData[x][y];
                    if (existingBlock !== null && (ignoreKey || existingBlock.blockKey !== key)) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        /**
         * Renders a block (or ghost) to the canvas, handling rotation and flipping.
         * @param {string} blockKey - The key of the block type.
         * @param {number} gridX - The grid X position.
         * @param {number} gridY - The grid Y position.
         * @param {number} rotation - The rotation angle (0, 90, 180, 270).
         * @param {boolean} flipped - If the block is horizontally flipped.
         * @param {boolean} isGhost - If true, renders a semi-transparent ghost version.
         * @param {boolean} isInvalid - If true, renders a red invalid ghost.
         */
        function renderBlock(blockKey, gridX, gridY, rotation, flipped, isGhost = false, isInvalid = false) {
            const blockDef = BLOCKS[blockKey];
            if (!blockDef) return;

            let [_, initialWidth, initialHeight, imagePath] = blockDef;
            
            // Determine the actual canvas dimensions in pixels (size after rotation)
            let drawWidth = initialWidth * CELL_PIXELS;
            let drawHeight = initialHeight * CELL_PIXELS;

            // The canvas coordinates for the center of the block
            const centerX = (gridX * CELL_PIXELS) + (drawWidth / 2);
            const centerY = (gridY * CELL_PIXELS) + (drawHeight / 2);

            ctx.save();
            
            // Apply pan and scale for the overall context
            ctx.translate(panX, panY);
            ctx.scale(scale, scale);

            // Translate to the center of the block for rotation/flip transformations
            ctx.translate(centerX, centerY);

            // Apply rotation (convert degrees to radians)
            ctx.rotate(rotation * Math.PI / 180);

            // Apply horizontal flip if needed
            if (flipped) {
                ctx.scale(-1, 1);
            }

            // If it's a ghost, apply semi-transparency
            if (isGhost) {
                ctx.globalAlpha = 0.5;
            }
            if (isInvalid) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(-drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                ctx.globalAlpha = 1.0; // Reset alpha for drawing the block color on top
            }
            
            // --- DRAW BLOCK LOGIC (Restored to Basic Shapes/Colors) ---
            
            let color = '#f0f0f0'; // Default fallback
            
            if (blockKey === 'FLOOR') {
                color = '#606060'; // Dark gray for floor
            } else if (blockKey === 'WALL') {
                color = '#303030'; // Very dark gray for wall
            } else if (blockKey === 'DOOR') {
                color = '#cc8400'; // Brown/Orange for door
            } else if (blockKey === 'BENCH') {
                color = '#3b82f6'; // Blue-500 for BENCH (blue rectangle)
            } else if (blockKey === 'RESEARCH') {
                color = '#8b5e32'; // Brown for RESEARCH (brown rectangle)
            } 
            
            ctx.fillStyle = color;
            
            // Draw the rectangle from the center point
            ctx.fillRect(-drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);

            // Draw a distinguishing feature for the research bench (as requested originally)
            if (blockKey === 'RESEARCH' && !isInvalid) {
                ctx.fillStyle = '#fde047'; // Yellow dot
                // Draw a small circle at the center of the block for visual distinction
                ctx.beginPath();
                ctx.arc(0, 0, drawWidth / 6, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Restore canvas state
            ctx.restore();
        }

        /**
         * Main drawing function. Clears the canvas and redraws everything.
         */
        function drawGrid() {
            // 1. Clear the canvas
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Apply transformations for drawing the grid and blocks
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(scale, scale);

            // 3. Draw the Grid Lines
            ctx.strokeStyle = '#505050';
            ctx.lineWidth = 1 / scale; // Keep line thickness constant on screen
            
            const totalCanvasWidth = GRID_SIZE * CELL_PIXELS;
            const totalCanvasHeight = GRID_SIZE * CELL_PIXELS;

            // Draw vertical lines
            for (let x = 0; x <= GRID_SIZE; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_PIXELS, 0);
                ctx.lineTo(x * CELL_PIXELS, totalCanvasHeight);
                ctx.stroke();
            }

            // Draw horizontal lines
            for (let y = 0; y <= GRID_SIZE; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_PIXELS);
                ctx.lineTo(totalCanvasWidth, y * CELL_PIXELS);
                ctx.stroke();
            }

            ctx.restore(); // Restore to normal context (only pan/scale applied for grid lines)


            // 4. Draw Existing Blocks
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const block = mapData[x][y];
                    if (block !== null) {
                        renderBlock(block.blockKey, x, y, block.rotation || 0, block.flipped || false, false);
                    }
                }
            }
            
            // 5. Draw the selection box if in LINE, DELETE, or CLONE mode and drawing
            if (isDrawing && (currentMode === MODES.LINE || currentMode === MODES.DELETE || currentMode === MODES.CLONE)) {
                // Calculate the selection box properties in screen space
                const { gridX: endGridX, gridY: endGridY } = ghostBlock;
                const minX = Math.min(startGridX, endGridX);
                const maxX = Math.max(startGridX, endGridX);
                const minY = Math.min(startGridY, endGridY);
                const maxY = Math.max(startGridY, endGridY);

                const width = (maxX - minX + 1) * CELL_PIXELS * scale;
                const height = (maxY - minY + 1) * CELL_PIXELS * scale;

                const startScreen = gridToCanvas(minX, minY);
                
                selectionBox.style.display = 'block';
                selectionBox.style.left = `${startScreen.screenX}px`;
                selectionBox.style.top = `${startScreen.screenY}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;

                // Render ghost placement for LINE mode (visual confirmation)
                if (currentMode === MODES.LINE) {
                    const lineBlockDef = BLOCKS[selectedBlockKey];
                    const lineBlockWidth = lineBlockDef[1];
                    const lineBlockHeight = lineBlockDef[2];

                    for (let x = minX; x <= maxX; x++) {
                        for (let y = minY; y <= maxY; y++) {
                             // Only draw block if it fits and is not already the same type
                            if (isValidPlacement(x, y, lineBlockWidth, lineBlockHeight, selectedBlockKey, true)) {
                                renderBlock(selectedBlockKey, x, y, ghostBlock.rotation, ghostBlock.flipped, true);
                            }
                        }
                    }
                }
            } else {
                selectionBox.style.display = 'none';
            }

            // 6. Draw the Ghost Block (Click mode only)
            if (currentMode === MODES.CLICK) {
                const blockDef = BLOCKS[selectedBlockKey];
                const [_, width, height] = blockDef;
                
                // Determine if placement is valid
                const isValid = isValidPlacement(ghostBlock.x, ghostBlock.y, width, height, selectedBlockKey, true);

                renderBlock(selectedBlockKey, ghostBlock.x, ghostBlock.y, ghostBlock.rotation, ghostBlock.flipped, true, !isValid);
            }
        }

        /**
         * Updates the Ghost Cursor's DOM element for the currently selected block.
         */
        function updateGhostCursor() {
            const blockDef = BLOCKS[selectedBlockKey];
            const [_, width, height] = blockDef;

            // Determine if placement is valid
            const isValid = isValidPlacement(ghostBlock.x, ghostBlock.y, width, height, selectedBlockKey, true);

            // Update DOM element position/style for the ghost cursor
            const { screenX, screenY } = gridToCanvas(ghostBlock.x, ghostBlock.y);
            
            // Calculate ghost size on screen (handles rotation)
            let ghostW = (width * CELL_PIXELS) * scale;
            let ghostH = (height * CELL_PIXELS) * scale;

            ghostCursor.style.left = `${screenX}px`;
            ghostCursor.style.top = `${screenY}px`;
            ghostCursor.style.width = `${ghostW}px`;
            ghostCursor.style.height = `${ghostH}px`;
            
            // Update class for invalid visual feedback
            if (!isValid) {
                ghostCursor.classList.add('invalid');
            } else {
                ghostCursor.classList.remove('invalid');
            }
            
            // The actual drawing of the block is done in drawGrid (renderBlock)
        }

        /**
         * Places the currently selected block at the given coordinates.
         * Handles removal if the block already exists.
         * @param {number} gridX - Top-left X coordinate.
         * @param {number} gridY - Top-left Y coordinate.
         */
        function placeBlock(gridX, gridY) {
            const blockDef = BLOCKS[selectedBlockKey];
            const [_, width, height] = blockDef;

            const existingBlock = mapData[gridX][gridY];

            // 1. Check if we are deleting an existing block
            if (existingBlock && existingBlock.blockKey === selectedBlockKey) {
                // Delete the entire block area
                const existingDef = BLOCKS[existingBlock.blockKey];
                const blockWidth = existingDef[1];
                const blockHeight = existingDef[2];
                
                for (let x = gridX; x < gridX + width; x++) {
                    for (let y = gridY; y < gridY + height; y++) {
                        // Only clear if the block at x,y is part of the block we clicked on.
                        if (mapData[x][y] && mapData[x][y].blockKey === selectedBlockKey) {
                            mapData[x][y] = null;
                        }
                    }
                }
                updateBlockCount();
                drawGrid();
                return;
            }

            // 2. Check if placement is valid (i.e., not overlapping a *different* block)
            if (!isValidPlacement(gridX, gridY, width, height, selectedBlockKey, true)) {
                // If invalid, and it's not the same block (for deletion), do nothing
                return;
            }

            // 3. Place the block (clear area first, then place new block across occupied cells)
            const newBlock = { 
                blockKey: selectedBlockKey, 
                rotation: ghostBlock.rotation,
                flipped: ghostBlock.flipped
            };
            
            // The rotation logic for coordinates is complex, but since we are transforming 
            // the drawing context, the placement coordinates (gridX, gridY) remain the top-left
            // of the block's *initial bounding box*.

            for (let x = gridX; x < gridX + width; x++) {
                for (let y = gridY; y < gridY + height; y++) {
                    // Check bounds again just in case
                    if (x < GRID_SIZE && y < GRID_SIZE) {
                        mapData[x][y] = newBlock;
                    }
                }
            }

            updateBlockCount();
            drawGrid();
        }

        /**
         * Handles placement logic for LINE mode.
         * @param {number} startX - Start grid X.
         * @param {number} startY - Start grid Y.
         * @param {number} endX - End grid X.
         * @param {number} endY - End grid Y.
         */
        function placeLine(startX, startY, endX, endY) {
            const minX = Math.min(startX, endX);
            const maxX = Math.max(startX, endX);
            const minY = Math.min(startY, endY);
            const maxY = Math.max(startY, endY);
            
            const blockDef = BLOCKS[selectedBlockKey];
            const width = blockDef[1];
            const height = blockDef[2];

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    // Check bounds and collision
                    if (isValidPlacement(x, y, width, height, selectedBlockKey, true)) {
                        const newBlock = { 
                            blockKey: selectedBlockKey, 
                            rotation: ghostBlock.rotation,
                            flipped: ghostBlock.flipped
                        };
                        
                        // Place the block cells
                        for (let bx = x; bx < x + width; bx++) {
                            for (let by = y; by < y + height; by++) {
                                if (bx < GRID_SIZE && by < GRID_SIZE) {
                                    mapData[bx][by] = newBlock;
                                }
                            }
                        }
                    }
                }
            }
            updateBlockCount();
            drawGrid();
        }
        
        /**
         * Handles deletion logic for DELETE mode.
         * @param {number} startX - Start grid X.
         * @param {number} startY - Start grid Y.
         * @param {number} endX - End grid X.
         * @param {number} endY - End grid Y.
         */
        function deleteArea(startX, startY, endX, endY) {
            const minX = Math.min(startX, endX);
            const maxX = Math.max(startX, endX);
            const minY = Math.min(startY, endY);
            const maxY = Math.max(startY, endY);

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    if (x < GRID_SIZE && y < GRID_SIZE) {
                        mapData[x][y] = null;
                    }
                }
            }
            updateBlockCount();
            drawGrid();
        }

        /**
         * Exports the map data to a JSON file.
         */
        function exportMapData() {
            // Simplify mapData for export: only export cells that are NOT null.
            const placedBlocks = [];
            
            // Keep track of cells already accounted for by a multi-cell block
            const visited = Array.from({ length: GRID_SIZE }, () => 
                Array(GRID_SIZE).fill(false)
            );

            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const cell = mapData[x][y];
                    
                    if (cell !== null && !visited[x][y]) {
                        const blockDef = BLOCKS[cell.blockKey];
                        const width = blockDef[1];
                        const height = blockDef[2];
                        
                        // This block starts at (x, y). Mark all its cells as visited.
                        for (let w = 0; w < width; w++) {
                            for (let h = 0; h < height; h++) {
                                // Ensure bounds check here is also necessary for map integrity
                                if (x + w < GRID_SIZE && y + h < GRID_SIZE) {
                                    visited[x + w][y + h] = true;
                                }
                            }
                        }

                        // Add the block definition using only its top-left coordinate
                        placedBlocks.push({
                            key: cell.blockKey,
                            x: x,
                            y: y,
                            r: cell.rotation || 0,
                            f: cell.flipped || false
                        });
                    }
                }
            }

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(placedBlocks, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "devast_base.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        /**
         * Imports map data from a JSON file.
         * @param {Event} event - The file input change event.
         */
        function importMapData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Reset map
                    mapData = Array.from({ length: GRID_SIZE }, () => 
                        Array.from({ length: GRID_SIZE }, () => null)
                    );
                    
                    // Process imported blocks
                    importedData.forEach(block => {
                        const blockKey = block.key;
                        const x = block.x;
                        const y = block.y;
                        const rotation = block.r || 0;
                        const flipped = block.f || false;
                        
                        const blockDef = BLOCKS[blockKey];
                        if (!blockDef) {
                            console.warn(`Skipping unknown block key: ${blockKey}`);
                            return;
                        }

                        const [_, width, height] = blockDef;
                        
                        // Check bounds
                        if (x < 0 || y < 0 || x + width > GRID_SIZE || y + height > GRID_SIZE) {
                            console.warn(`Skipping block out of bounds: ${blockKey} at (${x}, ${y})`);
                            return;
                        }

                        const newBlock = { blockKey, rotation, flipped };

                        // Place the block (mark all its occupied cells)
                        for (let bx = x; bx < x + width; bx++) {
                            for (let by = y; by < y + height; by++) {
                                mapData[bx][by] = newBlock;
                            }
                        }
                    });

                    updateBlockCount();
                    drawGrid();
                    console.log("Map data imported successfully.");
                } catch (error) {
                    alert("Failed to parse map data. Please ensure it is a valid JSON file.");
                    console.error("Import error:", error);
                }
            };
            reader.readAsText(file);
        }

        /**
         * Clears all blocks from the map.
         */
        function clearMap() {
            if (confirm("Are you sure you want to clear the entire map? This cannot be undone.")) {
                mapData = Array.from({ length: GRID_SIZE }, () => 
                    Array.from({ length: GRID_SIZE }, () => null)
                );
                updateBlockCount();
                drawGrid();
            }
        }

        /**
         * Rotates the ghost block.
         * @param {number} degrees - Degrees to rotate by (e.g., 90).
         */
        function rotateGhost(degrees) {
            ghostBlock.rotation = (ghostBlock.rotation + degrees) % 360;
            // When rotating 90 or 270 degrees, swap the width and height for collision check
            if (degrees === 90 || degrees === 270) {
                const temp = ghostBlock.width;
                ghostBlock.width = ghostBlock.height;
                ghostBlock.height = temp;
            }
            updateGhostCursor();
            drawGrid();
        }
        
        /**
         * Flips the ghost block horizontally.
         */
        function flipGhost() {
            ghostBlock.flipped = !ghostBlock.flipped;
            updateGhostCursor();
            drawGrid();
        }

        /**
         * Populates the block selector dropdown with available BLOCKS.
         */
        function populateBlockSelector() {
            const selector = document.getElementById('block-selector');
            selector.innerHTML = ''; // Clear existing options
            
            for (const key in BLOCKS) {
                const option = document.createElement('option');
                option.value = key;
                // Format key to be user-friendly (e.g., WALL -> Wall)
                option.textContent = key.charAt(0).toUpperCase() + key.slice(1).toLowerCase().replace('_', ' ');
                selector.appendChild(option);
            }
            
            // Set initial selected block
            selector.value = selectedBlockKey;
        }

        /**
         * Updates the currently selected block and ghost properties.
         */
        function updateSelectedBlock() {
            const selector = document.getElementById('block-selector');
            selectedBlockKey = selector.value;
            
            const blockDef = BLOCKS[selectedBlockKey];
            ghostBlock.key = selectedBlockKey;
            ghostBlock.width = blockDef[1];
            ghostBlock.height = blockDef[2];
            ghostBlock.rotation = 0; // Reset rotation on block change
            ghostBlock.flipped = false; // Reset flip on block change
            
            drawGrid();
        }
        
        /**
         * Updates the current placement mode and styling.
         * @param {string} mode - The new mode (e.g., MODES.CLICK).
         */
        function setMode(mode) {
            currentMode = mode;
            // Update button styles
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('bg-blue-600', 'bg-red-600', 'bg-yellow-600');
                btn.classList.add('bg-gray-600');
            });

            const activeBtn = document.getElementById(`mode-${mode.toLowerCase()}`);
            if (activeBtn) {
                if (mode === MODES.DELETE) {
                    activeBtn.classList.remove('bg-gray-600');
                    activeBtn.classList.add('bg-red-600');
                } else if (mode === MODES.CLONE) {
                    activeBtn.classList.remove('bg-gray-600');
                    activeBtn.classList.add('bg-yellow-600');
                } else {
                    activeBtn.classList.remove('bg-gray-600');
                    activeBtn.classList.add('bg-blue-600');
                }
            }

            // Hide selection box/ghost on mode change
            isDrawing = false;
            ghostCursor.style.display = 'none';
            selectionBox.style.display = 'none';
            drawGrid(); // Redraw to clear visual aids
        }

        /**
         * Updates the visible block count.
         */
        function updateBlockCount() {
            let count = 0;
            // Use a visited array to count only the top-left cell of each block
            const visited = Array.from({ length: GRID_SIZE }, () => 
                Array(GRID_SIZE).fill(false)
            );
            
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const cell = mapData[x][y];
                    if (cell !== null && !visited[x][y]) {
                        count++;
                        const blockDef = BLOCKS[cell.blockKey];
                        const width = blockDef[1];
                        const height = blockDef[2];
                        // Mark all cells of this block as visited
                        for (let w = 0; w < width; w++) {
                            for (let h = 0; h < height; h++) {
                                if (x + w < GRID_SIZE && y + h < GRID_SIZE) {
                                    visited[x + w][y + h] = true;
                                }
                            }
                        }
                    }
                }
            }
            blockCountDisplay.textContent = `Total Blocks Placed: ${count}`;
        }
        
        /**
         * Shows or hides the help modal.
         */
        function toggleHelpModal() {
            const modal = document.getElementById('helpModal');
            modal.classList.toggle('hidden');
        }


        // --- Event Handlers ---

        function handleWheel(event) {
            event.preventDefault();

            // Calculate zoom center point in virtual coordinates
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Coordinates in the virtual (unscaled, unpanned) grid space
            const virtualX = (mouseX / scale) - panX;
            const virtualY = (mouseY / scale) - panY;

            // Determine new scale
            const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1; // 10% zoom in/out
            scale = Math.max(0.2, Math.min(5.0, scale * zoomFactor)); // Clamp scale

            // Recalculate pan to keep the center point (virtualX, virtualY) fixed on screen
            panX = (mouseX / scale) - virtualX;
            panY = (mouseY / scale) - virtualY;

            // Redraw everything
            drawGrid();
            updateGhostCursor();
        }

        function handleMouseDown(event) {
            const { gridX, gridY } = clientToGrid(event.clientX, event.clientY);
            
            if (event.button === 1) { // Middle mouse button for panning
                isPanning = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                canvas.style.cursor = 'move';
            } else if (event.button === 0) { // Left mouse button for placement/drawing
                if (currentMode === MODES.CLICK) {
                    placeBlock(gridX, gridY);
                } else if (currentMode === MODES.LINE || currentMode === MODES.DELETE || currentMode === MODES.CLONE) {
                    isDrawing = true;
                    startGridX = gridX;
                    startGridY = gridY;
                }
            }
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const { gridX, gridY } = clientToGrid(event.clientX, event.clientY);

            // 1. Panning Logic
            if (isPanning) {
                const dx = event.clientX - lastMouseX;
                const dy = event.clientY - lastMouseY;
                
                // Adjust pan (not scaled by zoom)
                panX += dx / scale;
                panY += dy / scale;
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                
                drawGrid();
            }

            // 2. Ghost Cursor Logic (always active when mouse is over canvas)
            if (event.clientX >= rect.left && event.clientX <= rect.right &&
                event.clientY >= rect.top && event.clientY <= rect.bottom) {
                
                // Show/update ghost cursor DOM element (only for CLICK mode)
                if (currentMode === MODES.CLICK || currentMode === MODES.LINE || currentMode === MODES.DELETE) {
                    ghostBlock.x = gridX;
                    ghostBlock.y = gridY;
                    ghostCursor.style.display = 'block';
                    updateGhostCursor();
                } else {
                    ghostCursor.style.display = 'none';
                }

                // Update coordinates display
                coordsDisplay.textContent = `X: ${gridX}, Y: ${gridY} (Virtual: ${Math.floor(panX + (event.clientX - rect.left) / scale)}, ${Math.floor(panY + (event.clientY - rect.top) / scale)})`;

            } else {
                ghostCursor.style.display = 'none';
                coordsDisplay.textContent = `X: --, Y: -- (Virtual: --, --)`;
            }

            // 3. Drawing/Selection Logic (LINE, DELETE, CLONE modes)
            if (isDrawing) {
                // Update the selection box position/size visually
                if (currentMode === MODES.LINE || currentMode === MODES.DELETE || currentMode === MODES.CLONE) {
                    // Update ghost position (which acts as the end point)
                    ghostBlock.x = gridX;
                    ghostBlock.y = gridY;
                    drawGrid();
                }
            }
        }

        function handleMouseUp(event) {
            if (event.button === 1) { // Middle mouse button
                isPanning = false;
                canvas.style.cursor = 'none';
            } else if (event.button === 0) { // Left mouse button
                if (isDrawing) {
                    isDrawing = false;
                    const endGridX = ghostBlock.x;
                    const endGridY = ghostBlock.y;
                    
                    if (currentMode === MODES.LINE) {
                        placeLine(startGridX, startGridY, endGridX, endGridY);
                    } else if (currentMode === MODES.DELETE) {
                        deleteArea(startGridX, startGridY, endGridX, endGridY);
                    } else if (currentMode === MODES.CLONE) {
                        // CLONE: Drag 1 (Selection)
                        if (cloneData === null) {
                            // Copy data from the selected area
                            const minX = Math.min(startGridX, endGridX);
                            const maxX = Math.max(startGridX, endGridX);
                            const minY = Math.min(startGridY, endGridY);
                            const maxY = Math.max(startGridY, endGridY);
                            
                            cloneData = [];
                            
                            for (let x = minX; x <= maxX; x++) {
                                const row = [];
                                for (let y = minY; y <= maxY; y++) {
                                    if (x < GRID_SIZE && y < GRID_SIZE) {
                                        // Clone the block object (not the reference)
                                        row.push(mapData[x][y] ? {...mapData[x][y]} : null); 
                                    } else {
                                        row.push(null);
                                    }
                                }
                                cloneData.push(row);
                            }
                            // Change ghost to represent the cloned block's size for step 2
                            ghostBlock.width = maxX - minX + 1;
                            ghostBlock.height = maxY - minY + 1;

                            alert(`Copied ${ghostBlock.width}x${ghostBlock.height} area. Click again to place.`);
                        } 
                        // CLONE: Drag 2 (Placement - handled by a separate click outside the isDrawing block)
                        // The next click will be handled by the click handler below.
                    }
                    
                    // Clear drawing state visuals
                    selectionBox.style.display = 'none';
                    drawGrid();
                }
            }
        }
        
        function handleMouseClick(event) {
            // CLONE mode second click: placement
            if (currentMode === MODES.CLONE && cloneData !== null && event.button === 0) {
                const { gridX, gridY } = clientToGrid(event.clientX, event.clientY);
                const cloneW = cloneData.length;
                const cloneH = cloneData[0].length;
                
                // 1. Check bounds for placement
                if (gridX + cloneW > GRID_SIZE || gridY + cloneH > GRID_SIZE) {
                    alert("Placement area is out of bounds.");
                    return;
                }
                
                // 2. Check for collision with existing *different* blocks
                let canPlace = true;
                for (let x = 0; x < cloneW; x++) {
                    for (let y = 0; y < cloneH; y++) {
                        const cellData = cloneData[x][y];
                        const existingBlock = mapData[gridX + x][gridY + y];
                        
                        if (cellData !== null && existingBlock !== null && existingBlock.blockKey !== cellData.blockKey) {
                             canPlace = false;
                             break;
                        }
                    }
                    if (!canPlace) break;
                }
                
                if (!canPlace) {
                    alert("Placement failed due to collision with existing blocks.");
                    return;
                }

                // 3. Place the cloned blocks
                for (let x = 0; x < cloneW; x++) {
                    for (let y = 0; y < cloneH; y++) {
                        const cellData = cloneData[x][y];
                        if (cellData !== null) {
                            // Note: This replaces whatever was there (including the same block type)
                            mapData[gridX + x][gridY + y] = cellData;
                        } else {
                            // If the cloned cell was empty, clear the target cell
                            mapData[gridX + x][gridY + y] = null;
                        }
                    }
                }
                
                cloneData = null; // Reset clone data
                // Reset ghost size/key to currently selected block for next operation
                updateSelectedBlock(); 
                updateBlockCount();
                drawGrid();
            }
        }

        function handleKeyDown(event) {
            // Pan with WASD keys
            const panStep = 32;
            if (event.key === 'w' || event.key === 'W') {
                panY += panStep / scale;
                drawGrid();
            } else if (event.key === 's' || event.key === 'S') {
                panY -= panStep / scale;
                drawGrid();
            } else if (event.key === 'a' || event.key === 'A') {
                panX += panStep / scale;
                drawGrid();
            } else if (event.key === 'd' || event.key === 'D') {
                panX -= panStep / scale;
                drawGrid();
            } else if (event.key === 'r' || event.key === 'R') {
                // Rotate ghost block
                rotateGhost(90);
                event.preventDefault(); // Prevent page scroll/refresh if active
            } else if (event.key === 'f' || event.key === 'F') {
                // Flip ghost block
                flipGhost();
            } else if (event.key === 'h' || event.key === 'H') {
                // Toggle help modal
                toggleHelpModal();
            }
        }


        // --- Initialization ---

        async function init() {
            // Set canvas size (always fill its container)
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;

            // Initialize mode and block
            populateBlockSelector();
            updateSelectedBlock();
            setMode(MODES.CLICK); 

            // Initial view setup: pan to center the 149x149 grid
            // Grid total size: 149 * 32 = 4768 virtual pixels
            // We want the center of the grid (2384) to be near the center of the canvas.
            // Simplified centering:
            panX = canvas.width / (2 * scale) - (GRID_SIZE * CELL_PIXELS) / 2;
            panY = canvas.height / (2 * scale) - (GRID_SIZE * CELL_PIXELS) / 2;


            // Setup Event Listeners
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleMouseClick);
            document.addEventListener('keydown', handleKeyDown);
            
            // Set up import listener
            document.getElementById('importFile').addEventListener('change', importMapData);

            // Initial Draw
            drawGrid();
            updateBlockCount(); 
            
            // Show help modal on first load
            toggleHelpModal();
        }
    </script>
</body>
</html>
