<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Devast Base Editor (H for Help)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for Game/App Styling */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* Dark background for contrast */
            overflow: hidden; /* Prevent body scroll */
        }
        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            width: 100%;
            height: 100%;
            overflow-y: auto; /* Allow scrolling if content is taller than screen */
        }
        /* Style the canvas to ensure it doesn't cause overflow and is treated as a block element */
        #gridCanvas {
            max-width: 90vh; /* Limit size to viewport height */
            max-height: 90vh; /* Limit size to viewport height */
            margin: auto;
            display: block;
            border: 2px solid #505050; /* A soft grey border for the canvas itself */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); /* Subtle shadow */
        }
        /* Hide scrollbar for webkit browsers */
        .app-container::-webkit-scrollbar {
            display: none;
        }
        /* Hide scrollbar for IE, Edge and Firefox */
        .app-container {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        .icon-btn {
            background-color: #374151; /* Darker slate background */
            color: #d1d5db; /* Light gray text */
            transition: background-color 0.15s;
        }
        .icon-btn:hover {
            background-color: #4b5563; /* Slightly lighter on hover */
        }
        .icon-btn.active {
            background-color: #4f46e5; /* Active/Selected color (Indigo-600) */
            color: white;
        }
        .icon-btn.delete-mode.active {
            background-color: #dc2626; /* Active/Selected color (Red-600) for Delete Mode */
        }
        .icon-btn.floor-mode.active {
            background-color: #f59e0b; /* Active/Selected color (Amber-500) for Floor Mode */
            color: black;
        }
        .tooltip {
            visibility: hidden;
            position: absolute;
            z-index: 10;
            background-color: #1f2937;
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            pointer-events: none;
            bottom: calc(100% + 5px); /* Position above the button */
            left: 50%;
            transform: translateX(-50%);
        }
        .icon-btn-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        /* Styling for the help modal */
        .modal {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <!-- Main Application Container -->
    <div class="app-container">

        <!-- Header/Title -->
        <h1 class="text-3xl font-bold my-4 text-indigo-400">Devast Base Editor</h1>

        <!-- Tool Selection / Menu -->
        <div class="flex flex-wrap justify-center gap-2 p-3 bg-gray-800 rounded-lg shadow-xl mb-4 max-w-full" id="menuContainer">
            <!-- Mode Buttons -->
            <div class="flex space-x-2 border-r border-gray-700 pr-2 mr-2">
                <div class="icon-btn-container relative">
                    <button id="mode-click" class="icon-btn p-2 rounded-md active" data-mode="click" title="Click Mode (Default)">üñ±Ô∏è</button>
                    <span class="tooltip">Click Mode (Default)</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="mode-line" class="icon-btn p-2 rounded-md" data-mode="line" title="Line Mode">üìè</button>
                    <span class="tooltip">Line Mode</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="mode-clone" class="icon-btn p-2 rounded-md" data-mode="clone" title="Clone Mode">üìã</button>
                    <span class="tooltip">Clone Mode</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="mode-delete" class="icon-btn p-2 rounded-md delete-mode" data-mode="delete" title="Delete Mode">üóëÔ∏è</button>
                    <span class="tooltip">Delete Mode</span>
                </div>
            </div>

            <!-- Object Selection Buttons -->
            <div class="flex space-x-2 border-r border-gray-700 pr-2 mr-2" id="objectSelection">
                <div class="icon-btn-container relative">
                    <button id="object-wall" class="icon-btn p-2 rounded-md" data-object="Wall" title="Wall (Cost: 2)">üß±</button>
                    <span class="tooltip">Wall (Cost: 2)</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="object-wood-plank" class="icon-btn p-2 rounded-md" data-object="Wood Plank" title="Wood Plank (Cost: 1)">ü™µ</button>
                    <span class="tooltip">Wood Plank (Cost: 1)</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="object-metal-plank" class="icon-btn p-2 rounded-md" data-object="Metal Plank" title="Metal Plank (Cost: 1)">üõ°Ô∏è</button>
                    <span class="tooltip">Metal Plank (Cost: 1)</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="object-fridge" class="icon-btn p-2 rounded-md" data-object="Fridge" title="Fridge (3x1) (Cost: 8)">üßä</button>
                    <span class="tooltip">Fridge (3x1) (Cost: 8) - Rotates with R</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="object-door" class="icon-btn p-2 rounded-md" data-object="Door" title="Door (1x1) (Cost: 3)">üö™</button>
                    <span class="tooltip">Door (1x1) (Cost: 3) - Rotates with R</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="object-bag" class="icon-btn p-2 rounded-md" data-object="Bag" title="Bag (1x1) (Cost: 1)">üõçÔ∏è</button>
                    <span class="tooltip">Bag (1x1) (Cost: 1) - Rotates with R</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="object-stash-box" class="icon-btn p-2 rounded-md" data-object="Stash Box" title="Stash Box (1x1) (Cost: 2)">üì¶</button>
                    <span class="tooltip">Stash Box (1x1) (Cost: 2)</span>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex space-x-2">
                <div class="icon-btn-container relative">
                    <button id="toggle-floor-view" class="icon-btn p-2 rounded-md floor-mode" title="Toggle Floor Layer View">üßÖ</button>
                    <span class="tooltip">Toggle Floor Layer View (Only edit floor tiles)</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="action-save" class="icon-btn p-2 rounded-md" title="Save Base Data">üíæ</button>
                    <span class="tooltip">Save Base Data</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="action-load" class="icon-btn p-2 rounded-md" title="Load Base Data">üìÇ</button>
                    <span class="tooltip">Load Base Data</span>
                </div>
                <div class="icon-btn-container relative">
                    <button id="action-help" class="icon-btn p-2 rounded-md" title="Show Help (H)">‚ùì</button>
                    <span class="tooltip">Show Help (H)</span>
                </div>
            </div>
        </div>

        <!-- Info Bar -->
        <div class="bg-gray-800 p-2 rounded-lg shadow-xl mb-4 w-full max-w-lg">
            <p id="info-bar" class="text-sm text-center text-gray-400">Click on an object or mode to begin. Press **H** for help.</p>
        </div>

        <!-- Canvas for Grid -->
        <canvas id="gridCanvas" class="shadow-2xl"></canvas>

        <!-- Stats/Cost Display -->
        <div class="bg-gray-800 p-3 rounded-lg shadow-xl mt-4 w-full max-w-lg flex justify-between">
            <p class="text-lg font-semibold text-indigo-300">Total Cost:</p>
            <p id="total-cost" class="text-lg font-bold text-green-400">0</p>
        </div>

    </div>

    <!-- Help Modal (Initially Hidden) -->
    <div id="helpModal" class="modal fixed inset-0 flex items-center justify-center hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl max-w-md w-full border border-indigo-500">
            <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4">
                <h2 class="text-2xl font-bold text-indigo-400">Editor Controls</h2>
                <button class="text-gray-400 hover:text-white text-3xl leading-none" onclick="document.getElementById('helpModal').classList.add('hidden')">&times;</button>
            </div>

            <div class="space-y-4">
                <h3 class="text-xl font-semibold text-indigo-300">Navigation</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
                    <li>**Zoom**: Use the **Scroll Wheel** (or pinch on touch devices).</li>
                    <li>**Pan/Move**: Use **WASD** keys or **Middle Mouse Click & Drag**.</li>
                    <li>**Rotate Ghost Preview**: Press **R** to rotate the object ghost before placing (only for applicable items like 3x1 features, **Fridge**, **Door**, or **Bag**).</li>
                    <li>**Toggle Help**: Press **H** to show/hide this modal.</li>
                </ul>
                
                <h3 class="text-xl font-semibold text-indigo-300">Layering and Restrictions</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
                    <li>**Floor View (üßÖ)**: When active, non-floor objects (Walls, Fridges, etc.) are drawn faintly. You can **ONLY** place or delete **Wood Plank** and **Metal Plank** floor tiles.</li>
                </ul>

                <h3 class="text-xl font-semibold text-indigo-300">Placement Modes</h3>
                <ul class="list-disc list-inside space-y-2 text-gray-300 ml-4">
                    <li>**Click (üñ±Ô∏è)**: Single click to place or remove the selected object.</li>
                    <li>**Line (üìè)**: Click and drag to quickly place objects in a straight line (horizontal or vertical).</li>
                    <li>**Clone (üìã)**: First drag a box to select an area, then click to place the copy of that area.</li>
                    <li>**Delete (üóëÔ∏è)**: Click and drag a box to delete all objects within that area.</li>
                </ul>
            </div>
            
            <div class="mt-6 text-center text-sm text-gray-500 border-t border-gray-700 pt-3">
                <p>The base grid is **149x149**. Start building by closing this window!</p>
            </div>
        </div>
    </div>

    <!-- JavaScript Game Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');
            const infoBar = document.getElementById('info-bar');
            const menuContainer = document.getElementById('menuContainer');
            const toggleFloorViewBtn = document.getElementById('toggle-floor-view');
            const totalCostDisplay = document.getElementById('total-cost');
            const helpModal = document.getElementById('helpModal');

            // --- Configuration ---
            const GRID_SIZE = 149;
            const TILE_SIZE = 24; // Initial tile size for display
            const MAX_ZOOM = 40;
            const MIN_ZOOM = 10;
            
            // Define colors
            const COLORS = {
                GRID_LINE: '#333333',
                FRIDGE: '#4a4a4a',
                WALL: '#94a3b8',
                WOOD_PLANK: '#783c18',
                METAL_PLANK: '#505a60',
                PLACING_GHOST: '#34d399', // Emerald-400 for Placing
                GHOST_BORDER: '#777777', // Grey color for Fridge/Door/Bag Ghost Border
                HIGHLIGHT: '#f87171', // Red-500 for Danger/Delete/Highlight
                TEXT: '#d1d5db',
                INFO: '#9ca3af',
                ERROR: '#ef4444',
                SELECTED_OBJECT: '#fde047',
                SELECT_BOX: 'rgba(251, 191, 36, 0.4)',
                DELETE_BOX: 'rgba(248, 113, 113, 0.4)',
                WARNING: '#f59e0b',
                DOOR: '#a3a3a3',
                BAG: '#60a5fa',
                STASH_BOX: '#777777',
            };

            // Define object properties and costs
            const OBJECTS = {
                'Wall': { color: COLORS.WALL, size: [1, 1], cost: 2, icon: 'üß±' },
                'Wood Plank': { color: COLORS.WOOD_PLANK, size: [1, 1], cost: 1, icon: 'ü™µ' },
                'Metal Plank': { color: COLORS.METAL_PLANK, size: [1, 1], cost: 1, icon: 'üõ°Ô∏è' },
                'Fridge': { color: COLORS.FRIDGE, size: [3, 1], rotatable: true, cost: 8, icon: 'üßä' },
                'Door': { color: COLORS.DOOR, size: [1, 1], rotatable: true, cost: 3, icon: 'üö™' },
                'Bag': { color: COLORS.BAG, size: [1, 1], rotatable: true, cost: 1, icon: 'üõçÔ∏è' },
                'Stash Box': { color: COLORS.STASH_BOX, size: [1, 1], cost: 2, icon: 'üì¶' },
            };
            
            // Define which objects belong to the floor layer for restriction/view toggling
            const FLOOR_OBJECTS = ['Wood Plank', 'Metal Plank'];

            // --- State Variables ---
            let grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
            let currentMode = 'click'; // 'click', 'line', 'clone', 'delete'
            let currentObject = 'Wall'; // The selected object type for placing
            let currentRotation = 0; // 0, 90, 180, 270 degrees
            let currentTileSize = TILE_SIZE;
            let offsetX = 0;
            let offsetY = 0;
            let isPanning = false;
            let panStartX, panStartY;
            let mouseX, mouseY; // Mouse position on canvas
            let startDragX, startDragY; // For line, clone, delete modes
            let isDragging = false;
            let isCloneAreaSelected = false;
            let cloneBuffer = [];
            let cloneSelectBox = null;
            let isHelpVisible = true; // Show help on load
            let isFloorView = false; // NEW state for floor layering view

            // --- Utility Functions ---

            // Sets the canvas size based on current TILE_SIZE and container size
            const setCanvasSize = () => {
                const container = canvas.parentElement;
                let size = Math.min(container.clientWidth * 0.9, window.innerHeight * 0.9);

                // Set canvas dimensions
                canvas.width = size;
                canvas.height = size;
                
                // Adjust for high DPI screens
                const dpr = window.devicePixelRatio || 1;
                canvas.style.width = `${canvas.width}px`;
                canvas.style.height = `${canvas.height}px`;
                canvas.width *= dpr;
                canvas.height *= dpr;
                ctx.scale(dpr, dpr);

                drawGrid();
            };

            // Gets the effective size (width, height) of an object based on rotation
            const getObjectSize = (objectType, rotation) => {
                const { size, rotatable } = OBJECTS[objectType];
                if (rotatable && (rotation === 90 || rotation === 270)) {
                    return [size[1], size[0]]; // Swap width and height
                }
                return size;
            };

            // Calculates the total cost of all objects on the grid
            const calculateCost = () => {
                let cost = 0;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (grid[r][c] && grid[r][c].origin) {
                            cost += OBJECTS[grid[r][c].type].cost;
                        }
                    }
                }
                return cost;
            };
            
            // Updates the total cost display
            const updateCostDisplay = () => {
                const cost = calculateCost();
                totalCostDisplay.textContent = cost.toLocaleString();
                if (cost > 0) {
                    totalCostDisplay.classList.remove('text-green-400');
                    totalCostDisplay.classList.add('text-yellow-400');
                } else {
                    totalCostDisplay.classList.remove('text-yellow-400');
                    totalCostDisplay.classList.add('text-green-400');
                }
            };

            // --- Drawing Functions ---

            const drawGrid = () => {
                ctx.fillStyle = '#1a1a1a'; // Dark background
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const renderSize = currentTileSize * GRID_SIZE;
                const canvasW = canvas.width / (window.devicePixelRatio || 1);
                const canvasH = canvas.height / (window.devicePixelRatio || 1);
                
                ctx.save();
                ctx.translate(canvasW / 2 + offsetX, canvasH / 2 + offsetY);
                ctx.translate(-renderSize / 2, -renderSize / 2);

                // 1. Draw Grid Lines
                ctx.strokeStyle = COLORS.GRID_LINE;
                ctx.lineWidth = 1;
                for (let i = 0; i <= GRID_SIZE; i++) {
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(i * currentTileSize, 0);
                    ctx.lineTo(i * currentTileSize, renderSize);
                    ctx.stroke();

                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(0, i * currentTileSize);
                    ctx.lineTo(renderSize, i * currentTileSize);
                    ctx.stroke();
                }

                // 2. Draw Placed Objects
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = grid[r][c];
                        if (cell && cell.origin) {
                            const { type, rotation } = cell;
                            const { color } = OBJECTS[type];
                            const [w, h] = getObjectSize(type, rotation);
                            
                            const isFloor = FLOOR_OBJECTS.includes(type);

                            ctx.save(); // Save context before applying alpha
                            
                            if (isFloorView && !isFloor) {
                                // Non-floor objects (Walls, Fridges) in floor view mode: Draw faintly
                                ctx.globalAlpha = 0.15; 
                            } else if (isFloorView && isFloor) {
                                // Floor objects in floor view mode: Draw fully
                                ctx.globalAlpha = 1.0;
                            } else {
                                // Normal view mode: Draw fully
                                ctx.globalAlpha = 1.0;
                            }

                            // Draw object
                            ctx.fillStyle = color;
                            ctx.fillRect(c * currentTileSize, r * currentTileSize, w * currentTileSize, h * currentTileSize);

                            // Draw border
                            ctx.strokeStyle = '#222222';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(c * currentTileSize, r * currentTileSize, w * currentTileSize, h * currentTileSize);
                            
                            ctx.restore(); // Restore context to full alpha
                        }
                    }
                }

                // 3. Draw Preview Ghost (if applicable)
                if (mouseX >= 0 && mouseY >= 0 && currentMode !== 'delete' && currentMode !== 'clone') {
                    const [tileX, tileY] = screenToGrid(mouseX, mouseY);
                    
                    // NEW: Prevent ghost drawing if in floor view and selected object is not floor
                    const isCurrentObjectFloor = FLOOR_OBJECTS.includes(currentObject);
                    if (isFloorView && !isCurrentObjectFloor) {
                         // Show warning ghost
                         if (tileX !== -1 && tileY !== -1) {
                            const [w, h] = getObjectSize(currentObject, currentRotation);
                            ctx.fillStyle = COLORS.ERROR;
                            ctx.globalAlpha = 0.6;
                            ctx.fillRect(tileX * currentTileSize, tileY * currentTileSize, w * currentTileSize, h * currentTileSize);
                            ctx.globalAlpha = 1.0;
                         }
                    } else if (tileX !== -1 && tileY !== -1) {
                        const { rotatable } = OBJECTS[currentObject];
                        const [w, h] = getObjectSize(currentObject, currentRotation);

                        // Placement Box
                        ctx.fillStyle = COLORS.PLACING_GHOST;
                        ctx.globalAlpha = 0.5;
                        ctx.fillRect(tileX * currentTileSize, tileY * currentTileSize, w * currentTileSize, h * currentTileSize);
                        ctx.globalAlpha = 1.0;
                        
                        // Rotatable object border (the "highlighted border" for fridge)
                        if (rotatable) {
                            ctx.strokeStyle = COLORS.GHOST_BORDER; 
                            ctx.lineWidth = 2;
                            ctx.strokeRect(tileX * currentTileSize, tileY * currentTileSize, w * currentTileSize, h * currentTileSize);
                        }
                    }
                }

                // 4. Draw Drag Box (Line, Clone, Delete modes)
                if (isDragging) {
                    const [startTileX, startTileY] = screenToGrid(startDragX, startDragY);
                    const [endTileX, endTileY] = screenToGrid(mouseX, mouseY);
                    
                    if (startTileX !== -1 && startTileY !== -1 && endTileX !== -1 && endTileY !== -1) {
                        const minX = Math.min(startTileX, endTileX);
                        const minY = Math.min(startTileY, endTileY);
                        const maxX = Math.max(startTileX, endTileX);
                        const maxY = Math.max(startTileY, endTileY);

                        const rectX = minX * currentTileSize;
                        const rectY = minY * currentTileSize;
                        const rectW = (maxX - minX + 1) * currentTileSize;
                        const rectH = (maxY - minY + 1) * currentTileSize;

                        let fillColor, strokeColor;

                        if (currentMode === 'delete') {
                            fillColor = COLORS.DELETE_BOX;
                            strokeColor = COLORS.HIGHLIGHT;
                        } else if (currentMode === 'clone') {
                            fillColor = COLORS.SELECT_BOX;
                            strokeColor = COLORS.SELECTED_OBJECT;
                        } else { // Line mode
                            fillColor = COLORS.SELECT_BOX;
                            strokeColor = COLORS.SELECTED_OBJECT;
                        }

                        ctx.fillStyle = fillColor;
                        ctx.fillRect(rectX, rectY, rectW, rectH);

                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(rectX, rectY, rectW, rectH);
                    }
                }
                
                // 5. Draw Clone Selection Box (Clone Mode)
                if (currentMode === 'clone' && cloneSelectBox) {
                    const { minX, minY, maxX, maxY } = cloneSelectBox;

                    const rectX = minX * currentTileSize;
                    const rectY = minY * currentTileSize;
                    const rectW = (maxX - minX + 1) * currentTileSize;
                    const rectH = (maxY - minY + 1) * currentTileSize;

                    ctx.fillStyle = COLORS.SELECT_BOX;
                    ctx.fillRect(rectX, rectY, rectW, rectH);

                    ctx.strokeStyle = COLORS.SELECTED_OBJECT;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(rectX, rectY, rectW, rectH);
                }


                ctx.restore();
                
                // Draw a boundary around the whole grid (optional, but good for visual)
                ctx.strokeStyle = '#505050';
                ctx.lineWidth = 4;
                ctx.strokeRect(canvasW / 2 + offsetX - renderSize / 2, canvasH / 2 + offsetY - renderSize / 2, renderSize, renderSize);
            };

            // --- Coordinate and Conversion Functions ---

            // Converts screen coordinates (mouse) to canvas coordinates
            const screenToCanvas = (screenX, screenY) => {
                const canvasRect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const canvasX = (screenX - canvasRect.left) / dpr;
                const canvasY = (screenY - canvasRect.top) / dpr;
                return [canvasX, canvasY];
            };

            // Converts canvas coordinates to grid tile coordinates
            const canvasToGrid = (canvasX, canvasY) => {
                const canvasW = canvas.width / (window.devicePixelRatio || 1);
                const canvasH = canvas.height / (window.devicePixelRatio || 1);
                const renderSize = currentTileSize * GRID_SIZE;

                // Adjust for pan offset
                const adjustedX = canvasX - (canvasW / 2 + offsetX) + (renderSize / 2);
                const adjustedY = canvasY - (canvasH / 2 + offsetY) + (renderSize / 2);

                // Convert to tile index
                const tileX = Math.floor(adjustedX / currentTileSize);
                const tileY = Math.floor(adjustedY / currentTileSize);

                if (tileX >= 0 && tileX < GRID_SIZE && tileY >= 0 && tileY < GRID_SIZE) {
                    return [tileX, tileY];
                }
                return [-1, -1]; // Out of bounds
            };

            // Combines screenToCanvas and canvasToGrid
            const screenToGrid = (screenX, screenY) => {
                const [canvasX, canvasY] = screenToCanvas(screenX, screenY);
                return canvasToGrid(canvasX, canvasY);
            };

            // --- Grid Manipulation Functions (Pure Logic, No UI Updates) ---
            
            // Checks if an object of size [w, h] can be placed at [r, c]
            const canPlace = (r, c, w, h) => {
                if (r < 0 || c < 0 || r + h > GRID_SIZE || c + w > GRID_SIZE) {
                    return false;
                }
                
                for (let row = r; row < r + h; row++) {
                    for (let col = c; col < c + w; col++) {
                        if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE) return false;
                        
                        // If cell is occupied by the origin of another object
                        if (grid[row][col] && grid[row][col].origin) {
                            return false;
                        }
                    }
                }
                return true;
            };

            // NEW: Core logic for placing an object. Returns status object. Does NOT update UI.
            const placeObjectLogic = (r, c, type, rotation) => {
                // 1. Restriction Check
                if (isFloorView && !FLOOR_OBJECTS.includes(type)) {
                    return { success: false, restricted: true }; 
                }
                
                const [w, h] = getObjectSize(type, rotation);
                
                // 2. Check placement feasibility
                if (!canPlace(r, c, w, h)) {
                    return { success: false, restricted: false };
                }
                
                // 3. Place the new object
                const newObject = { type, rotation, origin: true };
                grid[r][c] = newObject;

                // 4. Mark all covered tiles (for multi-tile objects)
                for (let row = r; row < r + h; row++) {
                    for (let col = c; col < c + w; col++) {
                        if (row !== r || col !== c) {
                            grid[row][col] = { type, origin: false, parent: {r, c} };
                        }
                    }
                }
                
                return { success: true, restricted: false };
            };

            // NEW: Core logic for removing an object. Returns status object. Does NOT update UI.
            const removeObjectLogic = (r, c) => {
                const cell = grid[r][c];
                if (!cell) return { success: false, type: null, restricted: false };

                let originR = r;
                let originC = c;
                let objType = cell.type;
                
                if (!cell.origin) {
                    if (!cell.parent) return { success: false, type: objType, restricted: false };
                    originR = cell.parent.r;
                    originC = cell.parent.c;
                    objType = grid[originR][originC]?.type || objType;
                    if (!objType) return { success: false, type: null, restricted: false };
                }
                
                // Restriction Check
                if (isFloorView && !FLOOR_OBJECTS.includes(objType)) {
                    return { success: false, type: objType, restricted: true };
                }

                // If the origin is null (e.g. somehow deleted while being processed), skip
                if (!grid[originR][originC]) return { success: false, type: objType, restricted: false };
                
                const { rotation } = grid[originR][originC];
                const [w, h] = getObjectSize(objType, rotation);
                
                // Clear the entire object area
                for (let row = originR; row < originR + h; row++) {
                    for (let col = originC; col < originC + w; col++) {
                        if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
                            // Only clear tiles that belong to this object to prevent clearing multiple origins accidentally
                            if (grid[row][col] && grid[row][col].type === objType) {
                                grid[row][col] = null;
                            }
                        }
                    }
                }
                return { success: true, type: objType, restricted: false };
            };


            // --- Input Handlers ---

            const showInfo = (message, color = COLORS.INFO) => {
                infoBar.textContent = message;
                infoBar.style.color = color;
            };

            const handleZoom = (event) => {
                event.preventDefault(); // Prevent default scroll
                const zoomFactor = event.deltaY < 0 ? 1.1 : 1 / 1.1; // 10% zoom step

                const newTileSize = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentTileSize * zoomFactor));

                // Calculate where the mouse is in the grid before zoom
                const [oldTileX, oldTileY] = screenToGrid(event.clientX, event.clientY);

                // Apply new zoom
                currentTileSize = newTileSize;
                setCanvasSize();

                // Calculate where the mouse is now in the grid after zoom
                const [newTileX, newTileY] = screenToGrid(event.clientX, event.clientY);

                // Adjust offset (panning) to keep the point under the cursor stationary (if valid)
                if (oldTileX !== -1 && oldTileY !== -1 && newTileX !== -1 && newTileY !== -1) {
                    const deltaX = (newTileX - oldTileX) * currentTileSize;
                    const deltaY = (newTileY - oldTileY) * currentTileSize;
                    offsetX -= deltaX;
                    offsetY -= deltaY;
                }
                
                drawGrid();
            };

            const handleMouseDown = (event) => {
                const [tileX, tileY] = screenToGrid(event.clientX, event.clientY);
                startDragX = event.clientX;
                startDragY = event.clientY;
                isDragging = true;
                
                if (event.button === 1 || event.button === 0 && event.ctrlKey) { // Middle click or Ctrl + Left click for Pan
                    isPanning = true;
                    panStartX = event.clientX;
                    panStartY = event.clientY;
                    return;
                }

                if (tileX === -1 || tileY === -1) {
                    isDragging = false; // Don't start drag if out of bounds
                    return;
                }
                
                // Mode-specific initial click logic
                if (currentMode === 'clone') {
                    if (isCloneAreaSelected) {
                        // Place the cloned buffer
                        let successfulPlacements = 0;
                        let restrictedCount = 0;
                        let lastRestrictedType = currentObject;

                        for (const item of cloneBuffer) {
                            const targetR = tileY + item.r;
                            const targetC = tileX + item.c;
                            
                            if (targetR >= 0 && targetR < GRID_SIZE && targetC >= 0 && targetC < GRID_SIZE) {
                                const result = placeObjectLogic(targetR, targetC, item.type, item.rotation);
                                
                                if (result.success) {
                                    successfulPlacements++;
                                } else if (result.restricted) {
                                    restrictedCount++;
                                    lastRestrictedType = item.type;
                                }
                            }
                        }

                        if (successfulPlacements > 0) {
                            showInfo(`Placed ${successfulPlacements} objects from clone buffer starting at [${tileX}, ${tileY}].`, COLORS.INFO);
                        } else if (restrictedCount > 0) {
                            showInfo(`Placement failed: Cannot place ${lastRestrictedType} (and ${restrictedCount - 1} others) in Floor View.`, COLORS.ERROR);
                        } else {
                            showInfo('Placement failed: Area is blocked or out of bounds.', COLORS.ERROR);
                        }
                        
                        isCloneAreaSelected = false;
                        cloneBuffer = [];
                        cloneSelectBox = null;
                        updateCostDisplay();
                        drawGrid();
                    } 
                }
            };

            const handleMouseMove = (event) => {
                const [canvasX, canvasY] = screenToCanvas(event.clientX, event.clientY);
                const [tileX, tileY] = canvasToGrid(canvasX, canvasY);

                // Update mouse position for drawing ghost
                mouseX = event.clientX;
                mouseY = event.clientY;

                if (isPanning) {
                    const dx = event.clientX - panStartX;
                    const dy = event.clientY - panStartY;
                    offsetX += dx;
                    offsetY += dy;
                    panStartX = event.clientX;
                    panStartY = event.clientY;
                } else if (isDragging) {
                    // Update info bar for drag/select modes
                    if (tileX !== -1 && tileY !== -1) {
                        let msg = `[${tileX}, ${tileY}] - `;
                        
                        if (currentMode === 'delete') {
                            msg += `Delete Mode. Drag to select area.`;
                        } else if (currentMode === 'clone' && !isCloneAreaSelected) {
                            msg += `Clone Mode: Select area to copy.`;
                        } else if (currentMode === 'line') {
                            msg += `Line Mode: Drag to create a line of ${currentObject}.`;
                        }

                        if (currentMode !== 'click' || event.buttons === 0) { // Keep info bar relevant
                             showInfo(msg, COLORS.INFO);
                        }
                    }
                } else {
                    // Update info bar for regular mouse movement (hovering over tiles)
                    if (tileX !== -1 && tileY !== -1) {
                        const cell = grid[tileY][tileX];
                        let objectInfo = 'Empty';
                        if (cell) {
                            if (cell.origin) {
                                objectInfo = `${cell.type} (Origin)`;
                            } else if (cell.parent) {
                                objectInfo = `${cell.type} (Part of object at [${cell.parent.c}, ${cell.parent.r}])`;
                            } else {
                                objectInfo = cell.type;
                            }
                        }
                        showInfo(`Tile [${tileX}, ${tileY}] - Object: ${objectInfo} - Mode: ${currentMode} - Selected: ${currentObject} ${isFloorView ? ' (Floor View üßÖ)' : ''}`, COLORS.INFO);
                    } else {
                        showInfo(`Mode: ${currentMode} - Selected: ${currentObject} ${isFloorView ? ' (Floor View üßÖ)' : ''}`, COLORS.INFO);
                    }
                }

                drawGrid();
            };

            const handleMouseUp = (event) => {
                isPanning = false;
                
                if (!isDragging) return;
                isDragging = false;
                
                const [startTileX, startTileY] = screenToGrid(startDragX, startDragY);
                const [endTileX, endTileY] = screenToGrid(event.clientX, event.clientY);

                if (startTileX === -1 || startTileY === -1 || endTileX === -1 || endTileY === -1) {
                    return;
                }
                
                const minX = Math.min(startTileX, endTileX);
                const minY = Math.min(startTileY, endTileY);
                const maxX = Math.max(startTileX, endTileX);
                const maxY = Math.max(startTileY, endTileY);

                if (currentMode === 'click') {
                    // Single click for place/remove
                    if (startTileX === endTileX && startTileY === endTileY) {
                        if (grid[startTileY][startTileX]) {
                            const result = removeObjectLogic(startTileY, startTileX);
                            if (result.success) {
                                showInfo(`Removed ${result.type} at [${startTileX}, ${startTileY}].`, COLORS.INFO);
                            } else if (result.restricted) {
                                showInfo(`Cannot remove ${result.type}: Only floor objects are editable in Floor View.`, COLORS.ERROR);
                            } else {
                                 showInfo(`Removal failed at [${startTileX}, ${startTileY}].`, COLORS.ERROR);
                            }
                        } else {
                            const result = placeObjectLogic(startTileY, startTileX, currentObject, currentRotation);
                            if (result.success) {
                                showInfo(`Placed ${currentObject} at [${startTileX}, ${startTileY}].`, COLORS.INFO);
                            } else if (result.restricted) {
                                showInfo(`Cannot place ${currentObject}: Only floor objects are editable in Floor View.`, COLORS.ERROR);
                            } else {
                                showInfo(`Placement failed: Area at [${startTileX}, ${startTileY}] is blocked.`, COLORS.ERROR);
                            }
                        }
                        updateCostDisplay();
                        drawGrid();
                    } 
                } else if (currentMode === 'line') {
                    // Line mode places the object along a straight line (horizontal or vertical)
                    let placedCount = 0;
                    let restrictedCount = 0;
                    
                    const processPlacement = (r, c) => {
                        const result = placeObjectLogic(r, c, currentObject, currentRotation);
                        if (result.success) {
                            placedCount++;
                        } else if (result.restricted) {
                            restrictedCount++;
                        }
                    }

                    if (Math.abs(startTileX - endTileX) > Math.abs(startTileY - endTileY)) {
                        // Horizontal line (or mostly horizontal)
                        const startR = startTileY;
                        const stepX = startTileX < endTileX ? 1 : -1;
                        for (let c = startTileX; c !== endTileX + stepX; c += stepX) {
                             processPlacement(startR, c);
                        }
                    } else {
                        // Vertical line (or mostly vertical)
                        const startC = startTileX;
                        const stepY = startTileY < endTileY ? 1 : -1;
                        for (let r = startTileY; r !== endTileY + stepY; r += stepY) {
                            processPlacement(r, startC);
                        }
                    }
                    
                    if (placedCount > 0) {
                        showInfo(`Placed ${placedCount} items in a line.`, COLORS.INFO);
                    } else if (restrictedCount > 0) {
                        showInfo(`Placement failed: Cannot place ${currentObject} in Floor View.`, COLORS.ERROR);
                    } else {
                        showInfo('Placement failed: Area is blocked or out of bounds.', COLORS.ERROR);
                    }
                    updateCostDisplay();
                    drawGrid();
                    
                } else if (currentMode === 'delete') {
                    // Delete mode removes all objects in the box
                    let removedCount = 0;
                    let attemptedCount = 0;
                    let restrictedCount = 0;
                    let lastRestrictedType = '';

                    for (let r = minY; r <= maxY; r++) {
                        for (let c = minX; c <= maxX; c++) {
                            const cell = grid[r][c];
                            if (cell && cell.origin) {
                                attemptedCount++;
                                const result = removeObjectLogic(r, c);
                                if (result.success) {
                                    removedCount++;
                                } else if (result.restricted) {
                                    restrictedCount++;
                                    lastRestrictedType = result.type;
                                }
                            }
                        }
                    }

                    if (removedCount > 0) {
                        showInfo(`Removed ${removedCount} object origins.`, COLORS.HIGHLIGHT);
                    } else if (restrictedCount > 0) {
                        showInfo(`Deletion failed: Cannot remove ${lastRestrictedType} (and ${restrictedCount - 1} others) in Floor View.`, COLORS.ERROR);
                    } else {
                        showInfo('No objects found to delete.', COLORS.INFO);
                    }
                    
                    updateCostDisplay();
                    drawGrid();
                    
                } else if (currentMode === 'clone') {
                    if (!isCloneAreaSelected) {
                        // Area selected for cloning
                        cloneBuffer = [];
                        
                        for (let r = minY; r <= maxY; r++) {
                            for (let c = minX; c <= maxX; c++) {
                                const cell = grid[r][c];
                                if (cell && cell.origin) {
                                    // Store relative coordinates and object data
                                    cloneBuffer.push({
                                        type: cell.type,
                                        rotation: cell.rotation,
                                        r: r - minY, // Relative row
                                        c: c - minX  // Relative col
                                    });
                                }
                            }
                        }
                        
                        if (cloneBuffer.length > 0) {
                            isCloneAreaSelected = true;
                            cloneSelectBox = { minX, minY, maxX, maxY };
                            showInfo(`Copied ${cloneBuffer.length} objects. Click on the grid to place the copy.`, COLORS.INFO);
                        } else {
                             showInfo(`No objects selected for cloning.`, COLORS.WARNING);
                        }
                    }
                    // Placement is handled on mousedown, so no logic here
                    drawGrid();
                }
            };

            const handleKeyDown = (event) => {
                if (event.key === 'r' || event.key === 'R') {
                    // Rotate the current object (if rotatable)
                    const { rotatable } = OBJECTS[currentObject];
                    if (rotatable) {
                        currentRotation = (currentRotation + 90) % 360;
                        showInfo(`Rotation set to ${currentRotation} degrees for ${currentObject}.`, COLORS.INFO);
                        drawGrid();
                    } else {
                        showInfo(`${currentObject} is not rotatable.`, COLORS.WARNING);
                    }
                } else if (event.key === 'h' || event.key === 'H') {
                    // Toggle Help Modal
                    isHelpVisible = !isHelpVisible;
                    helpModal.classList.toggle('hidden', !isHelpVisible);
                }
                
                // Panning with WASD
                const PAN_SPEED = 20;
                if (event.key === 'w' || event.key === 'W') {
                    offsetY += PAN_SPEED;
                } else if (event.key === 's' || event.key === 'S') {
                    offsetY -= PAN_SPEED;
                } else if (event.key === 'a' || event.key === 'A') {
                    offsetX += PAN_SPEED;
                } else if (event.key === 'd' || event.key === 'D') {
                    offsetX -= PAN_SPEED;
                }

                drawGrid();
            };
            
            // --- Save/Load Functions ---

            const saveBase = () => {
                const objectArray = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = grid[r][c];
                        if (cell && cell.origin) {
                            objectArray.push({
                                type: cell.type,
                                r: r,
                                c: c,
                                rotation: cell.rotation
                            });
                        }
                    }
                }
                
                try {
                    const baseData = JSON.stringify(objectArray);
                    localStorage.setItem('devastBaseEditorData', baseData);
                    showInfo(`Base saved successfully! (${objectArray.length} objects)`, COLORS.INFO);
                } catch (e) {
                    showInfo(`Failed to save base: ${e.message}`, COLORS.ERROR);
                }
            };

            const loadBase = () => {
                try {
                    const baseData = localStorage.getItem('devastBaseEditorData');
                    if (baseData) {
                        const objectArray = JSON.parse(baseData);
                        // Reset grid and state
                        grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
                        let loadedCount = 0;
                        
                        objectArray.forEach(obj => {
                            const result = placeObjectLogic(obj.r, obj.c, obj.type, obj.rotation);
                            if (result.success) {
                                loadedCount++;
                            }
                        });

                        showInfo(`Base loaded successfully! (${loadedCount} objects)`, COLORS.INFO);
                        updateCostDisplay();
                        drawGrid();
                    } else {
                        showInfo('No saved base found in local storage.', COLORS.WARNING);
                    }
                } catch (e) {
                    showInfo(`Failed to load base: ${e.message}`, COLORS.ERROR);
                }
            };
            
            // --- Event Listeners and Initialization ---
            
            // Event listeners for tool/object selection
            menuContainer.addEventListener('click', (event) => {
                const button = event.target.closest('button');
                if (!button) return;

                // Handle Mode change
                if (button.id.startsWith('mode-')) {
                    const newMode = button.dataset.mode;
                    currentMode = newMode;
                    isCloneAreaSelected = false; // Reset clone state
                    cloneBuffer = [];
                    cloneSelectBox = null;
                    
                    // Update active class for mode buttons
                    document.querySelectorAll('[id^="mode-"]').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    showInfo(`Mode set to ${newMode}.`, COLORS.INFO);
                } 
                // Handle Object change
                else if (button.id.startsWith('object-')) {
                    const newObject = button.dataset.object;
                    currentObject = newObject;
                    currentRotation = 0; // Reset rotation on object change
                    
                    // Update active class for object buttons
                    document.querySelectorAll('[id^="object-"]').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    showInfo(`Selected object: ${newObject}.`, COLORS.INFO);
                }
                // Handle Actions
                else if (button.id === 'toggle-floor-view') {
                    isFloorView = !isFloorView;
                    button.classList.toggle('active', isFloorView);
                    
                    if (isFloorView) {
                        showInfo('FLOOR VIEW ON (üßÖ): Only Wood Plank and Metal Plank are editable.', COLORS.WARNING);
                    } else {
                        showInfo('Floor View OFF: All objects are editable.', COLORS.INFO);
                    }
                } else if (button.id === 'action-save') {
                    saveBase();
                } else if (button.id === 'action-load') {
                    loadBase();
                } else if (button.id === 'action-help') {
                    isHelpVisible = true;
                    helpModal.classList.remove('hidden');
                }
                
                drawGrid();
            });


            // Canvas Interaction Listeners
            canvas.addEventListener('wheel', handleZoom);
            canvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('resize', setCanvasSize);
            
            // Prevent context menu (right-click)
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // Initial setup
            setCanvasSize();
            helpModal.classList.remove('hidden'); // Show help on startup
            showInfo('Welcome! Press **H** for help.', COLORS.INFO);
        });
    </script>
</body>
</html>
